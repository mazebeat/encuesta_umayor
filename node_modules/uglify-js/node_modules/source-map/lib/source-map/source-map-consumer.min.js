if (typeof define !== "function") {
	var define = require("amdefine")(module, require)
}
define(function (d, f, b) {
	var g = d("./util");
	var k = d("./binary-search");
	var a = d("./array-set").ArraySet;
	var n = d("./base64-vlq");

	function o(t) {
		var s = t;
		if (typeof t === "string") {
			s = JSON.parse(t.replace(/^\)\]\}'/, ""))
		}
		var u = g.getArg(s, "version");
		var p = g.getArg(s, "sources");
		var w = g.getArg(s, "names", []);
		var x = g.getArg(s, "sourceRoot", null);
		var v = g.getArg(s, "sourcesContent", null);
		var r = g.getArg(s, "mappings");
		var q = g.getArg(s, "file", null);
		if (u != this._version) {
			throw new Error("Unsupported version: " + u)
		}
		this._names = a.fromArray(w, true);
		this._sources = a.fromArray(p, true);
		this.sourceRoot = x;
		this.sourcesContent = v;
		this._mappings = r;
		this.file = q
	}

	o.fromSourceMap = function c(p) {
		var q = Object.create(o.prototype);
		q._names = a.fromArray(p._names.toArray(), true);
		q._sources = a.fromArray(p._sources.toArray(), true);
		q.sourceRoot = p._sourceRoot;
		q.sourcesContent = p._generateSourcesContent(q._sources.toArray(), q.sourceRoot);
		q.file = p._file;
		q.__generatedMappings = p._mappings.slice().sort(g.compareByGeneratedPositions);
		q.__originalMappings = p._mappings.slice().sort(g.compareByOriginalPositions);
		return q
	};
	o.prototype._version = 3;
	Object.defineProperty(o.prototype, "sources", {
		get: function () {
			return this._sources.toArray().map(function (p) {
				return this.sourceRoot ? g.join(this.sourceRoot, p) : p
			}, this)
		}
	});
	o.prototype.__generatedMappings = null;
	Object.defineProperty(o.prototype, "_generatedMappings", {
		get: function () {
			if (!this.__generatedMappings) {
				this.__generatedMappings = [];
				this.__originalMappings = [];
				this._parseMappings(this._mappings, this.sourceRoot)
			}
			return this.__generatedMappings
		}
	});
	o.prototype.__originalMappings = null;
	Object.defineProperty(o.prototype, "_originalMappings", {
		get: function () {
			if (!this.__originalMappings) {
				this.__generatedMappings = [];
				this.__originalMappings = [];
				this._parseMappings(this._mappings, this.sourceRoot)
			}
			return this.__originalMappings
		}
	});
	o.prototype._parseMappings = function j(u, s) {
		var r = 1;
		var q = 0;
		var A = 0;
		var x = 0;
		var t = 0;
		var v = 0;
		var y = /^[,;]/;
		var w = u;
		var p;
		var z;
		while (w.length > 0) {
			if (w.charAt(0) === ";") {
				r++;
				w = w.slice(1);
				q = 0
			} else {
				if (w.charAt(0) === ",") {
					w = w.slice(1)
				} else {
					p = {};
					p.generatedLine = r;
					z = n.decode(w);
					p.generatedColumn = q + z.value;
					q = p.generatedColumn;
					w = z.rest;
					if (w.length > 0 && !y.test(w.charAt(0))) {
						z = n.decode(w);
						p.source = this._sources.at(t + z.value);
						t += z.value;
						w = z.rest;
						if (w.length === 0 || y.test(w.charAt(0))) {
							throw new Error("Found a source, but no line and column")
						}
						z = n.decode(w);
						p.originalLine = A + z.value;
						A = p.originalLine;
						p.originalLine += 1;
						w = z.rest;
						if (w.length === 0 || y.test(w.charAt(0))) {
							throw new Error("Found a source and line, but no column")
						}
						z = n.decode(w);
						p.originalColumn = x + z.value;
						x = p.originalColumn;
						w = z.rest;
						if (w.length > 0 && !y.test(w.charAt(0))) {
							z = n.decode(w);
							p.name = this._names.at(v + z.value);
							v += z.value;
							w = z.rest
						}
					}
					this.__generatedMappings.push(p);
					if (typeof p.originalLine === "number") {
						this.__originalMappings.push(p)
					}
				}
			}
		}
		this.__generatedMappings.sort(g.compareByGeneratedPositions);
		this.__originalMappings.sort(g.compareByOriginalPositions)
	};
	o.prototype._findMapping = function e(s, t, r, p, q) {
		if (s[r] <= 0) {
			throw new TypeError("Line must be greater than or equal to 1, got " + s[r])
		}
		if (s[p] < 0) {
			throw new TypeError("Column must be greater than or equal to 0, got " + s[p])
		}
		return k.search(s, t, q)
	};
	o.prototype.originalPositionFor = function m(s) {
		var r = {generatedLine: g.getArg(s, "line"), generatedColumn: g.getArg(s, "column")};
		var p = this._findMapping(r, this._generatedMappings, "generatedLine", "generatedColumn", g.compareByGeneratedPositions);
		if (p && p.generatedLine === r.generatedLine) {
			var q = g.getArg(p, "source", null);
			if (q && this.sourceRoot) {
				q = g.join(this.sourceRoot, q)
			}
			return {
				source: q,
				line: g.getArg(p, "originalLine", null),
				column: g.getArg(p, "originalColumn", null),
				name: g.getArg(p, "name", null)
			}
		}
		return {source: null, line: null, column: null, name: null}
	};
	o.prototype.sourceContentFor = function i(q) {
		if (!this.sourcesContent) {
			return null
		}
		if (this.sourceRoot) {
			q = g.relative(this.sourceRoot, q)
		}
		if (this._sources.has(q)) {
			return this.sourcesContent[this._sources.indexOf(q)]
		}
		var p;
		if (this.sourceRoot && (p = g.urlParse(this.sourceRoot))) {
			var r = q.replace(/^file:\/\//, "");
			if (p.scheme == "file" && this._sources.has(r)) {
				return this.sourcesContent[this._sources.indexOf(r)]
			}
			if ((!p.path || p.path == "/") && this._sources.has("/" + q)) {
				return this.sourcesContent[this._sources.indexOf("/" + q)]
			}
		}
		throw new Error('"' + q + '" is not in the SourceMap.')
	};
	o.prototype.generatedPositionFor = function h(r) {
		var q = {
			source: g.getArg(r, "source"),
			originalLine: g.getArg(r, "line"),
			originalColumn: g.getArg(r, "column")
		};
		if (this.sourceRoot) {
			q.source = g.relative(this.sourceRoot, q.source)
		}
		var p = this._findMapping(q, this._originalMappings, "originalLine", "originalColumn", g.compareByOriginalPositions);
		if (p) {
			return {line: g.getArg(p, "generatedLine", null), column: g.getArg(p, "generatedColumn", null)}
		}
		return {line: null, column: null}
	};
	o.GENERATED_ORDER = 1;
	o.ORIGINAL_ORDER = 2;
	o.prototype.eachMapping = function l(r, t, v) {
		var s = t || null;
		var q = v || o.GENERATED_ORDER;
		var u;
		switch (q) {
			case o.GENERATED_ORDER:
				u = this._generatedMappings;
				break;
			case o.ORIGINAL_ORDER:
				u = this._originalMappings;
				break;
			default:
				throw new Error("Unknown order of iteration.")
		}
		var p = this.sourceRoot;
		u.map(function (w) {
			var x = w.source;
			if (x && p) {
				x = g.join(p, x)
			}
			return {
				source: x,
				generatedLine: w.generatedLine,
				generatedColumn: w.generatedColumn,
				originalLine: w.originalLine,
				originalColumn: w.originalColumn,
				name: w.name
			}
		}).forEach(r, s)
	};
	f.SourceMapConsumer = o
});
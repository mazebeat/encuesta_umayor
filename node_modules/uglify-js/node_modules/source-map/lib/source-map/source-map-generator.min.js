if (typeof define !== "function") {
	var define = require("amdefine")(module, require)
}
define(function (e, h, d) {
	var p = e("./base64-vlq");
	var j = e("./util");
	var b = e("./array-set").ArraySet;

	function n(q) {
		if (!q) {
			q = {}
		}
		this._file = j.getArg(q, "file", null);
		this._sourceRoot = j.getArg(q, "sourceRoot", null);
		this._sources = new b();
		this._names = new b();
		this._mappings = [];
		this._sourcesContents = null
	}

	n.prototype._version = 3;
	n.fromSourceMap = function i(r) {
		var q = r.sourceRoot;
		var s = new n({file: r.file, sourceRoot: q});
		r.eachMapping(function (t) {
			var u = {generated: {line: t.generatedLine, column: t.generatedColumn}};
			if (t.source) {
				u.source = t.source;
				if (q) {
					u.source = j.relative(q, u.source)
				}
				u.original = {line: t.originalLine, column: t.originalColumn};
				if (t.name) {
					u.name = t.name
				}
			}
			s.addMapping(u)
		});
		r.sources.forEach(function (t) {
			var u = r.sourceContentFor(t);
			if (u) {
				s.setSourceContent(t, u)
			}
		});
		return s
	};
	n.prototype.addMapping = function l(u) {
		var q = j.getArg(u, "generated");
		var s = j.getArg(u, "original", null);
		var t = j.getArg(u, "source", null);
		var r = j.getArg(u, "name", null);
		this._validateMapping(q, s, t, r);
		if (t && !this._sources.has(t)) {
			this._sources.add(t)
		}
		if (r && !this._names.has(r)) {
			this._names.add(r)
		}
		this._mappings.push({
			generatedLine: q.line,
			generatedColumn: q.column,
			originalLine: s != null && s.line,
			originalColumn: s != null && s.column,
			source: t,
			name: r
		})
	};
	n.prototype.setSourceContent = function c(q, s) {
		var r = q;
		if (this._sourceRoot) {
			r = j.relative(this._sourceRoot, r)
		}
		if (s !== null) {
			if (!this._sourcesContents) {
				this._sourcesContents = {}
			}
			this._sourcesContents[j.toSetString(r)] = s
		} else {
			delete this._sourcesContents[j.toSetString(r)];
			if (Object.keys(this._sourcesContents).length === 0) {
				this._sourcesContents = null
			}
		}
	};
	n.prototype.applySourceMap = function m(t, s, r) {
		if (!s) {
			if (!t.file) {
				throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.')
			}
			s = t.file
		}
		var q = this._sourceRoot;
		if (q) {
			s = j.relative(q, s)
		}
		var v = new b();
		var u = new b();
		this._mappings.forEach(function (x) {
			if (x.source === s && x.originalLine) {
				var y = t.originalPositionFor({line: x.originalLine, column: x.originalColumn});
				if (y.source !== null) {
					x.source = y.source;
					if (r) {
						x.source = j.join(r, x.source)
					}
					if (q) {
						x.source = j.relative(q, x.source)
					}
					x.originalLine = y.line;
					x.originalColumn = y.column;
					if (y.name !== null && x.name !== null) {
						x.name = y.name
					}
				}
			}
			var z = x.source;
			if (z && !v.has(z)) {
				v.add(z)
			}
			var w = x.name;
			if (w && !u.has(w)) {
				u.add(w)
			}
		}, this);
		this._sources = v;
		this._names = u;
		t.sources.forEach(function (w) {
			var x = t.sourceContentFor(w);
			if (x) {
				if (r) {
					w = j.join(r, w)
				}
				if (q) {
					w = j.relative(q, w)
				}
				this.setSourceContent(w, x)
			}
		}, this)
	};
	n.prototype._validateMapping = function a(q, s, r, t) {
		if (q && "line" in q && "column" in q && q.line > 0 && q.column >= 0 && !s && !r && !t) {
			return
		} else {
			if (q && "line" in q && "column" in q && s && "line" in s && "column" in s && q.line > 0 && q.column >= 0 && s.line > 0 && s.column >= 0 && r) {
				return
			} else {
				throw new Error("Invalid mapping: " + JSON.stringify({generated: q, source: r, original: s, name: t}))
			}
		}
	};
	n.prototype._serializeMappings = function g() {
		var q = 0;
		var x = 1;
		var w = 0;
		var y = 0;
		var v = 0;
		var s = 0;
		var z = "";
		var r;
		this._mappings.sort(j.compareByGeneratedPositions);
		for (var t = 0, u = this._mappings.length; t < u; t++) {
			r = this._mappings[t];
			if (r.generatedLine !== x) {
				q = 0;
				while (r.generatedLine !== x) {
					z += ";";
					x++
				}
			} else {
				if (t > 0) {
					if (!j.compareByGeneratedPositions(r, this._mappings[t - 1])) {
						continue
					}
					z += ","
				}
			}
			z += p.encode(r.generatedColumn - q);
			q = r.generatedColumn;
			if (r.source) {
				z += p.encode(this._sources.indexOf(r.source) - s);
				s = this._sources.indexOf(r.source);
				z += p.encode(r.originalLine - 1 - y);
				y = r.originalLine - 1;
				z += p.encode(r.originalColumn - w);
				w = r.originalColumn;
				if (r.name) {
					z += p.encode(this._names.indexOf(r.name) - v);
					v = this._names.indexOf(r.name)
				}
			}
		}
		return z
	};
	n.prototype._generateSourcesContent = function f(r, q) {
		return r.map(function (t) {
			if (!this._sourcesContents) {
				return null
			}
			if (q) {
				t = j.relative(q, t)
			}
			var s = j.toSetString(t);
			return Object.prototype.hasOwnProperty.call(this._sourcesContents, s) ? this._sourcesContents[s] : null
		}, this)
	};
	n.prototype.toJSON = function k() {
		var q = {
			version: this._version,
			file: this._file,
			sources: this._sources.toArray(),
			names: this._names.toArray(),
			mappings: this._serializeMappings()
		};
		if (this._sourceRoot) {
			q.sourceRoot = this._sourceRoot
		}
		if (this._sourcesContents) {
			q.sourcesContent = this._generateSourcesContent(q.sources, q.sourceRoot)
		}
		return q
	};
	n.prototype.toString = function o() {
		return JSON.stringify(this)
	};
	h.SourceMapGenerator = n
});
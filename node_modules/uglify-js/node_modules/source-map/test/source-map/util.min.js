if (typeof define !== "function") {
	var define = require("amdefine")(module, require)
}
define(function (d, b, e) {
	var a = d("../../lib/source-map/util");
	b.testGeneratedCode = " ONE.foo=function(a){return baz(a);};\n TWO.inc=function(a){return a+1;};";
	b.testMap = {
		version: 3,
		file: "min.js",
		names: ["bar", "baz", "n"],
		sources: ["one.js", "two.js"],
		sourceRoot: "/the/root",
		mappings: "CAAC,IAAI,IAAM,SAAUA,GAClB,OAAOC,IAAID;CCDb,IAAI,IAAM,SAAUE,GAClB,OAAOA"
	};
	b.testMapWithSourcesContent = {
		version: 3,
		file: "min.js",
		names: ["bar", "baz", "n"],
		sources: ["one.js", "two.js"],
		sourcesContent: [" ONE.foo = function (bar) {\n   return baz(bar);\n };", " TWO.inc = function (n) {\n   return n + 1;\n };"],
		sourceRoot: "/the/root",
		mappings: "CAAC,IAAI,IAAM,SAAUA,GAClB,OAAOC,IAAID;CCDb,IAAI,IAAM,SAAUE,GAClB,OAAOA"
	};
	b.emptyMap = {version: 3, file: "min.js", names: [], sources: [], mappings: ""};
	function f(j, l, q, o, s, k, i, h, p, n) {
		if (!n) {
			var m = i.originalPositionFor({line: j, column: l});
			h.equal(m.name, k, "Incorrect name, expected " + JSON.stringify(k) + ", got " + JSON.stringify(m.name));
			h.equal(m.line, o, "Incorrect line, expected " + JSON.stringify(o) + ", got " + JSON.stringify(m.line));
			h.equal(m.column, s, "Incorrect column, expected " + JSON.stringify(s) + ", got " + JSON.stringify(m.column));
			var r;
			if (q && i.sourceRoot && q.indexOf(i.sourceRoot) === 0) {
				r = q
			} else {
				if (q) {
					r = i.sourceRoot ? a.join(i.sourceRoot, q) : q
				} else {
					r = null
				}
			}
			h.equal(m.source, r, "Incorrect source, expected " + JSON.stringify(r) + ", got " + JSON.stringify(m.source))
		}
		if (!p) {
			var g = i.generatedPositionFor({source: q, line: o, column: s});
			h.equal(g.line, j, "Incorrect line, expected " + JSON.stringify(j) + ", got " + JSON.stringify(g.line));
			h.equal(g.column, l, "Incorrect column, expected " + JSON.stringify(l) + ", got " + JSON.stringify(g.column))
		}
	}

	b.assertMapping = f;
	function c(g, k, h) {
		g.equal(k.version, h.version, "version mismatch");
		g.equal(k.file, h.file, "file mismatch");
		g.equal(k.names.length, h.names.length, "names length mismatch: " + k.names.join(", ") + " != " + h.names.join(", "));
		for (var j = 0; j < k.names.length; j++) {
			g.equal(k.names[j], h.names[j], "names[" + j + "] mismatch: " + k.names.join(", ") + " != " + h.names.join(", "))
		}
		g.equal(k.sources.length, h.sources.length, "sources length mismatch: " + k.sources.join(", ") + " != " + h.sources.join(", "));
		for (var j = 0; j < k.sources.length; j++) {
			g.equal(k.sources[j], h.sources[j], "sources[" + j + "] length mismatch: " + k.sources.join(", ") + " != " + h.sources.join(", "))
		}
		g.equal(k.sourceRoot, h.sourceRoot, "sourceRoot mismatch: " + k.sourceRoot + " != " + h.sourceRoot);
		g.equal(k.mappings, h.mappings, "mappings mismatch:\nActual:   " + k.mappings + "\nExpected: " + h.mappings);
		if (k.sourcesContent) {
			g.equal(k.sourcesContent.length, h.sourcesContent.length, "sourcesContent length mismatch");
			for (var j = 0; j < k.sourcesContent.length; j++) {
				g.equal(k.sourcesContent[j], h.sourcesContent[j], "sourcesContent[" + j + "] mismatch")
			}
		}
	}

	b.assertEqualMaps = c
});
"use strict";
function Compressor(a, b) {
	if (!(this instanceof Compressor)) {
		return new Compressor(a, b)
	}
	TreeTransformer.call(this, this.before, this.after);
	this.options = defaults(a, {
		sequences: !b,
		properties: !b,
		dead_code: !b,
		drop_debugger: !b,
		unsafe: false,
		unsafe_comps: false,
		conditionals: !b,
		comparisons: !b,
		evaluate: !b,
		booleans: !b,
		loops: !b,
		unused: !b,
		hoist_funs: !b,
		keep_fargs: false,
		hoist_vars: false,
		if_return: !b,
		join_vars: !b,
		cascade: !b,
		side_effects: !b,
		pure_getters: false,
		pure_funcs: null,
		negate_iife: !b,
		screw_ie8: false,
		drop_console: false,
		angular: false,
		warnings: true,
		global_defs: {}
	}, true)
}
Compressor.prototype = new TreeTransformer;
merge(Compressor.prototype, {
	option: function (a) {
		return this.options[a]
	}, warn: function () {
		if (this.options.warnings) {
			AST_Node.warn.apply(AST_Node, arguments)
		}
	}, before: function (c, a, b) {
		if (c._squeezed) {
			return c
		}
		var d = false;
		if (c instanceof AST_Scope) {
			c = c.hoist_declarations(this);
			d = true
		}
		a(c, this);
		c = c.optimize(this);
		if (d && c instanceof AST_Scope) {
			c.drop_unused(this);
			a(c, this)
		}
		c._squeezed = true;
		return c
	}
});
(function () {
	function k(q, p) {
		q.DEFMETHOD("optimize", function (t) {
			var r = this;
			if (r._optimized) {
				return r
			}
			var s = p(r, t);
			s._optimized = true;
			if (s === r) {
				return s
			}
			return s.transform(t)
		})
	}

	k(AST_Node, function (p, q) {
		return p
	});
	AST_Node.DEFMETHOD("equivalent_to", function (p) {
		return this.print_to_string() == p.print_to_string()
	});
	function m(q, r, p) {
		if (!p) {
			p = {}
		}
		if (r) {
			if (!p.start) {
				p.start = r.start
			}
			if (!p.end) {
				p.end = r.end
			}
		}
		return new q(p)
	}

	function n(r, p, q) {
		if (p instanceof AST_Node) {
			return p.transform(r)
		}
		switch (typeof p) {
			case"string":
				return m(AST_String, q, {value: p}).optimize(r);
			case"number":
				return m(isNaN(p) ? AST_NaN : AST_Number, q, {value: p}).optimize(r);
			case"boolean":
				return m(p ? AST_True : AST_False, q).optimize(r);
			case"undefined":
				return m(AST_Undefined, q).optimize(r);
			default:
				if (p === null) {
					return m(AST_Null, q).optimize(r)
				}
				if (p instanceof RegExp) {
					return m(AST_RegExp, q).optimize(r)
				}
				throw new Error(string_template("Can't handle constant of type: {type}", {type: typeof p}))
		}
	}

	function g(p) {
		if (p === null) {
			return []
		}
		if (p instanceof AST_BlockStatement) {
			return p.body
		}
		if (p instanceof AST_EmptyStatement) {
			return []
		}
		if (p instanceof AST_Statement) {
			return [p]
		}
		throw new Error("Can't convert thing to statement array")
	}

	function e(p) {
		if (p === null) {
			return true
		}
		if (p instanceof AST_EmptyStatement) {
			return true
		}
		if (p instanceof AST_BlockStatement) {
			return p.body.length == 0
		}
		return false
	}

	function i(p) {
		if (p instanceof AST_Switch) {
			return p
		}
		if (p instanceof AST_For || p instanceof AST_ForIn || p instanceof AST_DWLoop) {
			return (p.body instanceof AST_BlockStatement ? p.body : p)
		}
		return p
	}

	function h(s, r) {
		var w;
		do {
			w = false;
			if (r.option("angular")) {
				s = y(s)
			}
			s = v(s);
			if (r.option("dead_code")) {
				s = t(s, r)
			}
			if (r.option("if_return")) {
				s = q(s, r)
			}
			if (r.option("sequences")) {
				s = u(s, r)
			}
			if (r.option("join_vars")) {
				s = z(s, r)
			}
		} while (w);
		if (r.option("negate_iife")) {
			x(s, r)
		}
		return s;
		function y(A) {
			function B(D, C) {
				return m(AST_SimpleStatement, D, {
					body: m(AST_Assign, D, {
						operator: "=",
						left: m(AST_Dot, C, {expression: m(AST_SymbolRef, C, C), property: "$inject"}),
						right: m(AST_Array, D, {
							elements: D.argnames.map(function (E) {
								return m(AST_String, E, {value: E.name})
							})
						})
					})
				})
			}

			return A.reduce(function (C, E) {
				C.push(E);
				var D = E.start;
				var G = D.comments_before;
				if (G && G.length > 0) {
					var F = G.pop();
					if (/@ngInject/.test(F.value)) {
						if (E instanceof AST_Defun) {
							C.push(B(E, E.name))
						} else {
							if (E instanceof AST_Definitions) {
								E.definitions.forEach(function (H) {
									if (H.value && H.value instanceof AST_Lambda) {
										C.push(B(H.value, H.name))
									}
								})
							} else {
								r.warn("Unknown statement marked with @ngInject [{file}:{line},{col}]", D)
							}
						}
					}
				}
				return C
			}, [])
		}

		function v(B) {
			var A = [];
			return B.reduce(function (C, D) {
				if (D instanceof AST_BlockStatement) {
					w = true;
					C.push.apply(C, v(D.body))
				} else {
					if (D instanceof AST_EmptyStatement) {
						w = true
					} else {
						if (D instanceof AST_Directive) {
							if (A.indexOf(D.value) < 0) {
								C.push(D);
								A.push(D.value)
							} else {
								w = true
							}
						} else {
							C.push(D)
						}
					}
				}
				return C
			}, [])
		}

		function q(E, A) {
			var I = A.self();
			var H = I instanceof AST_Lambda;
			var F = [];
			loop:for (var C = E.length; --C >= 0;) {
				var B = E[C];
				switch (true) {
					case (H && B instanceof AST_Return && !B.value && F.length == 0):
						w = true;
						continue loop;
					case B instanceof AST_If:
						if (B.body instanceof AST_Return) {
							if (((H && F.length == 0) || (F[0] instanceof AST_Return && !F[0].value)) && !B.body.value && !B.alternative) {
								w = true;
								var G = m(AST_SimpleStatement, B.condition, {body: B.condition});
								F.unshift(G);
								continue loop
							}
							if (F[0] instanceof AST_Return && B.body.value && F[0].value && !B.alternative) {
								w = true;
								B = B.clone();
								B.alternative = F[0];
								F[0] = B.transform(A);
								continue loop
							}
							if ((F.length == 0 || F[0] instanceof AST_Return) && B.body.value && !B.alternative && H) {
								w = true;
								B = B.clone();
								B.alternative = F[0] || m(AST_Return, B, {value: m(AST_Undefined, B)});
								F[0] = B.transform(A);
								continue loop
							}
							if (!B.body.value && H) {
								w = true;
								B = B.clone();
								B.condition = B.condition.negate(A);
								B.body = m(AST_BlockStatement, B, {body: g(B.alternative).concat(F)});
								B.alternative = null;
								F = [B.transform(A)];
								continue loop
							}
							if (F.length == 1 && H && F[0] instanceof AST_SimpleStatement && (!B.alternative || B.alternative instanceof AST_SimpleStatement)) {
								w = true;
								F.push(m(AST_Return, F[0], {value: m(AST_Undefined, F[0])}).transform(A));
								F = g(B.alternative).concat(F);
								F.unshift(B);
								continue loop
							}
						}
						var K = l(B.body);
						var J = K instanceof AST_LoopControl ? A.loopcontrol_target(K.label) : null;
						if (K && ((K instanceof AST_Return && !K.value && H) || (K instanceof AST_Continue && I === i(J)) || (K instanceof AST_Break && J instanceof AST_BlockStatement && I === J))) {
							if (K.label) {
								remove(K.label.thedef.references, K)
							}
							w = true;
							var D = g(B.body).slice(0, -1);
							B = B.clone();
							B.condition = B.condition.negate(A);
							B.body = m(AST_BlockStatement, B, {body: g(B.alternative).concat(F)});
							B.alternative = m(AST_BlockStatement, B, {body: D});
							F = [B.transform(A)];
							continue loop
						}
						var K = l(B.alternative);
						var J = K instanceof AST_LoopControl ? A.loopcontrol_target(K.label) : null;
						if (K && ((K instanceof AST_Return && !K.value && H) || (K instanceof AST_Continue && I === i(J)) || (K instanceof AST_Break && J instanceof AST_BlockStatement && I === J))) {
							if (K.label) {
								remove(K.label.thedef.references, K)
							}
							w = true;
							B = B.clone();
							B.body = m(AST_BlockStatement, B.body, {body: g(B.body).concat(F)});
							B.alternative = m(AST_BlockStatement, B.alternative, {body: g(B.alternative).slice(0, -1)});
							F = [B.transform(A)];
							continue loop
						}
						F.unshift(B);
						break;
					default:
						F.unshift(B);
						break
				}
			}
			return F
		}

		function t(C, E) {
			var A = false;
			var D = C.length;
			var B = E.self();
			C = C.reduce(function (G, H) {
				if (A) {
					o(E, H, G)
				} else {
					if (H instanceof AST_LoopControl) {
						var F = E.loopcontrol_target(H.label);
						if ((H instanceof AST_Break && F instanceof AST_BlockStatement && i(F) === B) || (H instanceof AST_Continue && i(F) === B)) {
							if (H.label) {
								remove(H.label.thedef.references, H)
							}
						} else {
							G.push(H)
						}
					} else {
						G.push(H)
					}
					if (l(H)) {
						A = true
					}
				}
				return G
			}, []);
			w = C.length != D;
			return C
		}

		function u(B, E) {
			if (B.length < 2) {
				return B
			}
			var A = [], C = [];

			function D() {
				A = AST_Seq.from_array(A);
				if (A) {
					C.push(m(AST_SimpleStatement, A, {body: A}))
				}
				A = []
			}

			B.forEach(function (F) {
				if (F instanceof AST_SimpleStatement) {
					A.push(F.body)
				} else {
					D(), C.push(F)
				}
			});
			D();
			C = p(C, E);
			w = C.length != B.length;
			return C
		}

		function p(A, E) {
			function C(F) {
				B.pop();
				var G = D.body;
				if (G instanceof AST_Seq) {
					G.add(F)
				} else {
					G = AST_Seq.cons(G, F)
				}
				return G.transform(E)
			}

			var B = [], D = null;
			A.forEach(function (H) {
				if (D) {
					if (H instanceof AST_For) {
						var F = {};
						try {
							D.body.walk(new TreeWalker(function (I) {
								if (I instanceof AST_Binary && I.operator == "in") {
									throw F
								}
							}));
							if (H.init && !(H.init instanceof AST_Definitions)) {
								H.init = C(H.init)
							} else {
								if (!H.init) {
									H.init = D.body;
									B.pop()
								}
							}
						} catch (G) {
							if (G !== F) {
								throw G
							}
						}
					} else {
						if (H instanceof AST_If) {
							H.condition = C(H.condition)
						} else {
							if (H instanceof AST_With) {
								H.expression = C(H.expression)
							} else {
								if (H instanceof AST_Exit && H.value) {
									H.value = C(H.value)
								} else {
									if (H instanceof AST_Exit) {
										H.value = C(m(AST_Undefined, H))
									} else {
										if (H instanceof AST_Switch) {
											H.expression = C(H.expression)
										}
									}
								}
							}
						}
					}
				}
				B.push(H);
				D = H instanceof AST_SimpleStatement ? H : null
			});
			return B
		}

		function z(A, C) {
			var B = null;
			return A.reduce(function (D, E) {
				if (E instanceof AST_Definitions && B && B.TYPE == E.TYPE) {
					B.definitions = B.definitions.concat(E.definitions);
					w = true
				} else {
					if (E instanceof AST_For && B instanceof AST_Definitions && (!E.init || E.init.TYPE == B.TYPE)) {
						w = true;
						D.pop();
						if (E.init) {
							E.init.definitions = B.definitions.concat(E.init.definitions)
						} else {
							E.init = B
						}
						D.push(E);
						B = E
					} else {
						B = E;
						D.push(E)
					}
				}
				return D
			}, [])
		}

		function x(A, B) {
			A.forEach(function (D) {
				if (D instanceof AST_SimpleStatement) {
					D.body = (function C(E) {
						return E.transform(new TreeTransformer(function (G) {
							if (G instanceof AST_Call && G.expression instanceof AST_Function) {
								return m(AST_UnaryPrefix, G, {operator: "!", expression: G})
							} else {
								if (G instanceof AST_Call) {
									G.expression = C(G.expression)
								} else {
									if (G instanceof AST_Seq) {
										G.car = C(G.car)
									} else {
										if (G instanceof AST_Conditional) {
											var H = C(G.condition);
											if (H !== G.condition) {
												G.condition = H;
												var F = G.consequent;
												G.consequent = G.alternative;
												G.alternative = F
											}
										}
									}
								}
							}
							return G
						}))
					})(D.body)
				}
			})
		}
	}

	function o(r, p, q) {
		r.warn("Dropping unreachable code [{file}:{line},{col}]", p.start);
		p.walk(new TreeWalker(function (s) {
			if (s instanceof AST_Definitions) {
				r.warn("Declarations in unreachable code! [{file}:{line},{col}]", s.start);
				s.remove_initializers();
				q.push(s);
				return true
			}
			if (s instanceof AST_Defun) {
				q.push(s);
				return true
			}
			if (s instanceof AST_Scope) {
				return true
			}
		}))
	}

	(function (q) {
		var p = ["!", "delete"];
		var r = ["in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">"];
		q(AST_Node, function () {
			return false
		});
		q(AST_UnaryPrefix, function () {
			return member(this.operator, p)
		});
		q(AST_Binary, function () {
			return member(this.operator, r) || ((this.operator == "&&" || this.operator == "||") && this.left.is_boolean() && this.right.is_boolean())
		});
		q(AST_Conditional, function () {
			return this.consequent.is_boolean() && this.alternative.is_boolean()
		});
		q(AST_Assign, function () {
			return this.operator == "=" && this.right.is_boolean()
		});
		q(AST_Seq, function () {
			return this.cdr.is_boolean()
		});
		q(AST_True, function () {
			return true
		});
		q(AST_False, function () {
			return true
		})
	})(function (q, p) {
		q.DEFMETHOD("is_boolean", p)
	});
	(function (p) {
		p(AST_Node, function () {
			return false
		});
		p(AST_String, function () {
			return true
		});
		p(AST_UnaryPrefix, function () {
			return this.operator == "typeof"
		});
		p(AST_Binary, function (q) {
			return this.operator == "+" && (this.left.is_string(q) || this.right.is_string(q))
		});
		p(AST_Assign, function (q) {
			return (this.operator == "=" || this.operator == "+=") && this.right.is_string(q)
		});
		p(AST_Seq, function (q) {
			return this.cdr.is_string(q)
		});
		p(AST_Conditional, function (q) {
			return this.consequent.is_string(q) && this.alternative.is_string(q)
		});
		p(AST_Call, function (q) {
			return q.option("unsafe") && this.expression instanceof AST_SymbolRef && this.expression.name == "String" && this.expression.undeclared()
		})
	})(function (q, p) {
		q.DEFMETHOD("is_string", p)
	});
	function f(q, p) {
		return q.print_to_string().length > p.print_to_string().length ? p : q
	}

	(function (q) {
		AST_Node.DEFMETHOD("evaluate", function (t) {
			if (!t.option("evaluate")) {
				return [this]
			}
			try {
				var s = this._eval(t);
				return [f(n(t, s, this), this), s]
			} catch (r) {
				if (r !== q) {
					throw r
				}
				return [this]
			}
		});
		q(AST_Statement, function () {
			throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start))
		});
		q(AST_Function, function () {
			throw q
		});
		function p(r, s) {
			if (!s) {
				throw new Error("Compressor must be passed")
			}
			return r._eval(s)
		}

		q(AST_Node, function () {
			throw q
		});
		q(AST_Constant, function () {
			return this.getValue()
		});
		q(AST_UnaryPrefix, function (s) {
			var r = this.expression;
			switch (this.operator) {
				case"!":
					return !p(r, s);
				case"typeof":
					if (r instanceof AST_Function) {
						return typeof function () {
						}
					}
					r = p(r, s);
					if (r instanceof RegExp) {
						throw q
					}
					return typeof r;
				case"void":
					return void p(r, s);
				case"~":
					return ~p(r, s);
				case"-":
					r = p(r, s);
					if (r === 0) {
						throw q
					}
					return -r;
				case"+":
					return +p(r, s)
			}
			throw q
		});
		q(AST_Binary, function (t) {
			var s = this.left, r = this.right;
			switch (this.operator) {
				case"&&":
					return p(s, t) && p(r, t);
				case"||":
					return p(s, t) || p(r, t);
				case"|":
					return p(s, t) | p(r, t);
				case"&":
					return p(s, t) & p(r, t);
				case"^":
					return p(s, t) ^ p(r, t);
				case"+":
					return p(s, t) + p(r, t);
				case"*":
					return p(s, t) * p(r, t);
				case"/":
					return p(s, t) / p(r, t);
				case"%":
					return p(s, t) % p(r, t);
				case"-":
					return p(s, t) - p(r, t);
				case"<<":
					return p(s, t) << p(r, t);
				case">>":
					return p(s, t) >> p(r, t);
				case">>>":
					return p(s, t) >>> p(r, t);
				case"==":
					return p(s, t) == p(r, t);
				case"===":
					return p(s, t) === p(r, t);
				case"!=":
					return p(s, t) != p(r, t);
				case"!==":
					return p(s, t) !== p(r, t);
				case"<":
					return p(s, t) < p(r, t);
				case"<=":
					return p(s, t) <= p(r, t);
				case">":
					return p(s, t) > p(r, t);
				case">=":
					return p(s, t) >= p(r, t);
				case"in":
					return p(s, t) in p(r, t);
				case"instanceof":
					return p(s, t) instanceof p(r, t)
			}
			throw q
		});
		q(AST_Conditional, function (r) {
			return p(this.condition, r) ? p(this.consequent, r) : p(this.alternative, r)
		});
		q(AST_SymbolRef, function (s) {
			var r = this.definition();
			if (r && r.constant && r.init) {
				return p(r.init, s)
			}
			throw q
		});
		q(AST_Dot, function (s) {
			if (s.option("unsafe") && this.property == "length") {
				var r = p(this.expression, s);
				if (typeof r == "string") {
					return r.length
				}
			}
			throw q
		})
	})(function (q, p) {
		q.DEFMETHOD("_eval", p)
	});
	(function (q) {
		function p(r) {
			return m(AST_UnaryPrefix, r, {operator: "!", expression: r})
		}

		q(AST_Node, function () {
			return p(this)
		});
		q(AST_Statement, function () {
			throw new Error("Cannot negate a statement")
		});
		q(AST_Function, function () {
			return p(this)
		});
		q(AST_UnaryPrefix, function () {
			if (this.operator == "!") {
				return this.expression
			}
			return p(this)
		});
		q(AST_Seq, function (s) {
			var r = this.clone();
			r.cdr = r.cdr.negate(s);
			return r
		});
		q(AST_Conditional, function (s) {
			var r = this.clone();
			r.consequent = r.consequent.negate(s);
			r.alternative = r.alternative.negate(s);
			return f(p(this), r)
		});
		q(AST_Binary, function (t) {
			var r = this.clone(), s = this.operator;
			if (t.option("unsafe_comps")) {
				switch (s) {
					case"<=":
						r.operator = ">";
						return r;
					case"<":
						r.operator = ">=";
						return r;
					case">=":
						r.operator = "<";
						return r;
					case">":
						r.operator = "<=";
						return r
				}
			}
			switch (s) {
				case"==":
					r.operator = "!=";
					return r;
				case"!=":
					r.operator = "==";
					return r;
				case"===":
					r.operator = "!==";
					return r;
				case"!==":
					r.operator = "===";
					return r;
				case"&&":
					r.operator = "||";
					r.left = r.left.negate(t);
					r.right = r.right.negate(t);
					return f(p(this), r);
				case"||":
					r.operator = "&&";
					r.left = r.left.negate(t);
					r.right = r.right.negate(t);
					return f(p(this), r)
			}
			return p(this)
		})
	})(function (q, p) {
		q.DEFMETHOD("negate", function (r) {
			return p.call(this, r)
		})
	});
	(function (p) {
		p(AST_Node, function (q) {
			return true
		});
		p(AST_EmptyStatement, function (q) {
			return false
		});
		p(AST_Constant, function (q) {
			return false
		});
		p(AST_This, function (q) {
			return false
		});
		p(AST_Call, function (r) {
			var q = r.option("pure_funcs");
			if (!q) {
				return true
			}
			return q.indexOf(this.expression.print_to_string()) < 0
		});
		p(AST_Block, function (r) {
			for (var q = this.body.length; --q >= 0;) {
				if (this.body[q].has_side_effects(r)) {
					return true
				}
			}
			return false
		});
		p(AST_SimpleStatement, function (q) {
			return this.body.has_side_effects(q)
		});
		p(AST_Defun, function (q) {
			return true
		});
		p(AST_Function, function (q) {
			return false
		});
		p(AST_Binary, function (q) {
			return this.left.has_side_effects(q) || this.right.has_side_effects(q)
		});
		p(AST_Assign, function (q) {
			return true
		});
		p(AST_Conditional, function (q) {
			return this.condition.has_side_effects(q) || this.consequent.has_side_effects(q) || this.alternative.has_side_effects(q)
		});
		p(AST_Unary, function (q) {
			return this.operator == "delete" || this.operator == "++" || this.operator == "--" || this.expression.has_side_effects(q)
		});
		p(AST_SymbolRef, function (q) {
			return false
		});
		p(AST_Object, function (r) {
			for (var q = this.properties.length; --q >= 0;) {
				if (this.properties[q].has_side_effects(r)) {
					return true
				}
			}
			return false
		});
		p(AST_ObjectProperty, function (q) {
			return this.value.has_side_effects(q)
		});
		p(AST_Array, function (r) {
			for (var q = this.elements.length; --q >= 0;) {
				if (this.elements[q].has_side_effects(r)) {
					return true
				}
			}
			return false
		});
		p(AST_Dot, function (q) {
			if (!q.option("pure_getters")) {
				return true
			}
			return this.expression.has_side_effects(q)
		});
		p(AST_Sub, function (q) {
			if (!q.option("pure_getters")) {
				return true
			}
			return this.expression.has_side_effects(q) || this.property.has_side_effects(q)
		});
		p(AST_PropAccess, function (q) {
			return !q.option("pure_getters")
		});
		p(AST_Seq, function (q) {
			return this.car.has_side_effects(q) || this.cdr.has_side_effects(q)
		})
	})(function (q, p) {
		q.DEFMETHOD("has_side_effects", p)
	});
	function l(p) {
		return p && p.aborts()
	}

	(function (p) {
		p(AST_Statement, function () {
			return null
		});
		p(AST_Jump, function () {
			return this
		});
		function q() {
			var r = this.body.length;
			return r > 0 && l(this.body[r - 1])
		}

		p(AST_BlockStatement, q);
		p(AST_SwitchBranch, q);
		p(AST_If, function () {
			return this.alternative && l(this.body) && l(this.alternative)
		})
	})(function (q, p) {
		q.DEFMETHOD("aborts", p)
	});
	k(AST_Directive, function (p, q) {
		if (p.scope.has_directive(p.value) !== p.scope) {
			return m(AST_EmptyStatement, p)
		}
		return p
	});
	k(AST_Debugger, function (p, q) {
		if (q.option("drop_debugger")) {
			return m(AST_EmptyStatement, p)
		}
		return p
	});
	k(AST_LabeledStatement, function (p, q) {
		if (p.body instanceof AST_Break && q.loopcontrol_target(p.body.label) === p.body) {
			return m(AST_EmptyStatement, p)
		}
		return p.label.references.length == 0 ? p.body : p
	});
	k(AST_Block, function (p, q) {
		p.body = h(p.body, q);
		return p
	});
	k(AST_BlockStatement, function (p, q) {
		p.body = h(p.body, q);
		switch (p.body.length) {
			case 1:
				return p.body[0];
			case 0:
				return m(AST_EmptyStatement, p)
		}
		return p
	});
	AST_Scope.DEFMETHOD("drop_unused", function (p) {
		var x = this;
		if (p.option("unused") && !(x instanceof AST_Toplevel) && !x.uses_eval) {
			var v = [];
			var r = new Dictionary();
			var w = this;
			var s = new TreeWalker(function (A, z) {
				if (A !== x) {
					if (A instanceof AST_Defun) {
						r.add(A.name.name, A);
						return true
					}
					if (A instanceof AST_Definitions && w === x) {
						A.definitions.forEach(function (B) {
							if (B.value) {
								r.add(B.name.name, B.value);
								if (B.value.has_side_effects(p)) {
									B.value.walk(s)
								}
							}
						});
						return true
					}
					if (A instanceof AST_SymbolRef) {
						push_uniq(v, A.definition());
						return true
					}
					if (A instanceof AST_Scope) {
						var y = w;
						w = A;
						z();
						w = y;
						return true
					}
				}
			});
			x.walk(s);
			for (var q = 0; q < v.length; ++q) {
				v[q].orig.forEach(function (y) {
					var z = r.get(y.name);
					if (z) {
						z.forEach(function (B) {
							var A = new TreeWalker(function (C) {
								if (C instanceof AST_SymbolRef) {
									push_uniq(v, C.definition())
								}
							});
							B.walk(A)
						})
					}
				})
			}
			var t = new TreeTransformer(function u(B, E, H) {
				if (B instanceof AST_Lambda && !(B instanceof AST_Accessor)) {
					if (!p.option("keep_fargs")) {
						for (var G = B.argnames, C = G.length; --C >= 0;) {
							var A = G[C];
							if (A.unreferenced()) {
								G.pop();
								p.warn("Dropping unused function argument {name} [{file}:{line},{col}]", {
									name: A.name,
									file: A.start.file,
									line: A.start.line,
									col: A.start.col
								})
							} else {
								break
							}
						}
					}
				}
				if (B instanceof AST_Defun && B !== x) {
					if (!member(B.name.definition(), v)) {
						p.warn("Dropping unused function {name} [{file}:{line},{col}]", {
							name: B.name.name,
							file: B.name.start.file,
							line: B.name.start.line,
							col: B.name.start.col
						});
						return m(AST_EmptyStatement, B)
					}
					return B
				}
				if (B instanceof AST_Definitions && !(t.parent() instanceof AST_ForIn)) {
					var y = B.definitions.filter(function (J) {
						if (member(J.name.definition(), v)) {
							return true
						}
						var I = {
							name: J.name.name,
							file: J.name.start.file,
							line: J.name.start.line,
							col: J.name.start.col
						};
						if (J.value && J.value.has_side_effects(p)) {
							J._unused_side_effects = true;
							p.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", I);
							return true
						}
						p.warn("Dropping unused variable {name} [{file}:{line},{col}]", I);
						return false
					});
					y = mergeSort(y, function (J, I) {
						if (!J.value && I.value) {
							return -1
						}
						if (!I.value && J.value) {
							return 1
						}
						return 0
					});
					var z = [];
					for (var C = 0; C < y.length;) {
						var F = y[C];
						if (F._unused_side_effects) {
							z.push(F.value);
							y.splice(C, 1)
						} else {
							if (z.length > 0) {
								z.push(F.value);
								F.value = AST_Seq.from_array(z);
								z = []
							}
							++C
						}
					}
					if (z.length > 0) {
						z = m(AST_BlockStatement, B, {body: [m(AST_SimpleStatement, B, {body: AST_Seq.from_array(z)})]})
					} else {
						z = null
					}
					if (y.length == 0 && !z) {
						return m(AST_EmptyStatement, B)
					}
					if (y.length == 0) {
						return z
					}
					B.definitions = y;
					if (z) {
						z.body.unshift(B);
						B = z
					}
					return B
				}
				if (B instanceof AST_For) {
					E(B, this);
					if (B.init instanceof AST_BlockStatement) {
						var D = B.init.body.slice(0, -1);
						B.init = B.init.body.slice(-1)[0].body;
						D.push(B);
						return H ? MAP.splice(D) : m(AST_BlockStatement, B, {body: D})
					}
				}
				if (B instanceof AST_Scope && B !== x) {
					return B
				}
			});
			x.transform(t)
		}
	});
	AST_Scope.DEFMETHOD("hoist_declarations", function (x) {
		var D = x.option("hoist_funs");
		var t = x.option("hoist_vars");
		var A = this;
		if (D || t) {
			var s = [];
			var E = [];
			var B = new Dictionary(), z = 0, u = 0;
			A.walk(new TreeWalker(function (H) {
				if (H instanceof AST_Scope && H !== A) {
					return true
				}
				if (H instanceof AST_Var) {
					++u;
					return true
				}
			}));
			t = t && u > 1;
			var p = new TreeTransformer(function w(I) {
				if (I !== A) {
					if (I instanceof AST_Directive) {
						s.push(I);
						return m(AST_EmptyStatement, I)
					}
					if (I instanceof AST_Defun && D) {
						E.push(I);
						return m(AST_EmptyStatement, I)
					}
					if (I instanceof AST_Var && t) {
						I.definitions.forEach(function (K) {
							B.set(K.name.name, K);
							++z
						});
						var H = I.to_assignments();
						var J = p.parent();
						if (J instanceof AST_ForIn && J.init === I) {
							if (H == null) {
								return I.definitions[0].name
							}
							return H
						}
						if (J instanceof AST_For && J.init === I) {
							return H
						}
						if (!H) {
							return m(AST_EmptyStatement, I)
						}
						return m(AST_SimpleStatement, I, {body: H})
					}
					if (I instanceof AST_Scope) {
						return I
					}
				}
			});
			A = A.transform(p);
			if (z > 0) {
				var q = [];
				B.each(function (I, H) {
					if (A instanceof AST_Lambda && find_if(function (J) {
							return J.name == I.name.name
						}, A.argnames)) {
						B.del(H)
					} else {
						I = I.clone();
						I.value = null;
						q.push(I);
						B.set(H, I)
					}
				});
				if (q.length > 0) {
					for (var F = 0; F < A.body.length;) {
						if (A.body[F] instanceof AST_SimpleStatement) {
							var r = A.body[F].body, v, C;
							if (r instanceof AST_Assign && r.operator == "=" && (v = r.left) instanceof AST_Symbol && B.has(v.name)) {
								var y = B.get(v.name);
								if (y.value) {
									break
								}
								y.value = r.right;
								remove(q, y);
								q.push(y);
								A.body.splice(F, 1);
								continue
							}
							if (r instanceof AST_Seq && (C = r.car) instanceof AST_Assign && C.operator == "=" && (v = C.left) instanceof AST_Symbol && B.has(v.name)) {
								var y = B.get(v.name);
								if (y.value) {
									break
								}
								y.value = C.right;
								remove(q, y);
								q.push(y);
								A.body[F].body = r.cdr;
								continue
							}
						}
						if (A.body[F] instanceof AST_EmptyStatement) {
							A.body.splice(F, 1);
							continue
						}
						if (A.body[F] instanceof AST_BlockStatement) {
							var G = [F, 1].concat(A.body[F].body);
							A.body.splice.apply(A.body, G);
							continue
						}
						break
					}
					q = m(AST_Var, A, {definitions: q});
					E.push(q)
				}
			}
			A.body = s.concat(E, A.body)
		}
		return A
	});
	k(AST_SimpleStatement, function (p, q) {
		if (q.option("side_effects")) {
			if (!p.body.has_side_effects(q)) {
				q.warn("Dropping side-effect-free statement [{file}:{line},{col}]", p.start);
				return m(AST_EmptyStatement, p)
			}
		}
		return p
	});
	k(AST_DWLoop, function (q, s) {
		var r = q.condition.evaluate(s);
		q.condition = r[0];
		if (!s.option("loops")) {
			return q
		}
		if (r.length > 1) {
			if (r[1]) {
				return m(AST_For, q, {body: q.body})
			} else {
				if (q instanceof AST_While) {
					if (s.option("dead_code")) {
						var p = [];
						o(s, q.body, p);
						return m(AST_BlockStatement, q, {body: p})
					}
				}
			}
		}
		return q
	});
	function b(p, s) {
		function q(t) {
			t = g(t);
			if (p.body instanceof AST_BlockStatement) {
				p.body = p.body.clone();
				p.body.body = t.concat(p.body.body.slice(1));
				p.body = p.body.transform(s)
			} else {
				p.body = m(AST_BlockStatement, p.body, {body: t}).transform(s)
			}
			b(p, s)
		}

		var r = p.body instanceof AST_BlockStatement ? p.body.body[0] : p.body;
		if (r instanceof AST_If) {
			if (r.body instanceof AST_Break && s.loopcontrol_target(r.body.label) === p) {
				if (p.condition) {
					p.condition = m(AST_Binary, p.condition, {
						left: p.condition,
						operator: "&&",
						right: r.condition.negate(s)
					})
				} else {
					p.condition = r.condition.negate(s)
				}
				q(r.alternative)
			} else {
				if (r.alternative instanceof AST_Break && s.loopcontrol_target(r.alternative.label) === p) {
					if (p.condition) {
						p.condition = m(AST_Binary, p.condition, {
							left: p.condition,
							operator: "&&",
							right: r.condition
						})
					} else {
						p.condition = r.condition
					}
					q(r.body)
				}
			}
		}
	}

	k(AST_While, function (p, q) {
		if (!q.option("loops")) {
			return p
		}
		p = AST_DWLoop.prototype.optimize.call(p, q);
		if (p instanceof AST_While) {
			b(p, q);
			p = m(AST_For, p, p).transform(q)
		}
		return p
	});
	k(AST_For, function (q, s) {
		var r = q.condition;
		if (r) {
			r = r.evaluate(s);
			q.condition = r[0]
		}
		if (!s.option("loops")) {
			return q
		}
		if (r) {
			if (r.length > 1 && !r[1]) {
				if (s.option("dead_code")) {
					var p = [];
					if (q.init instanceof AST_Statement) {
						p.push(q.init)
					} else {
						if (q.init) {
							p.push(m(AST_SimpleStatement, q.init, {body: q.init}))
						}
					}
					o(s, q.body, p);
					return m(AST_BlockStatement, q, {body: p})
				}
			}
		}
		b(q, s);
		return q
	});
	k(AST_If, function (x, r) {
		if (!r.option("conditionals")) {
			return x
		}
		var v = x.condition.evaluate(r);
		x.condition = v[0];
		if (v.length > 1) {
			if (v[1]) {
				r.warn("Condition always true [{file}:{line},{col}]", x.condition.start);
				if (r.option("dead_code")) {
					var w = [];
					if (x.alternative) {
						o(r, x.alternative, w)
					}
					w.push(x.body);
					return m(AST_BlockStatement, x, {body: w}).transform(r)
				}
			} else {
				r.warn("Condition always false [{file}:{line},{col}]", x.condition.start);
				if (r.option("dead_code")) {
					var w = [];
					o(r, x.body, w);
					if (x.alternative) {
						w.push(x.alternative)
					}
					return m(AST_BlockStatement, x, {body: w}).transform(r)
				}
			}
		}
		if (e(x.alternative)) {
			x.alternative = null
		}
		var p = x.condition.negate(r);
		var q = f(x.condition, p) === p;
		if (x.alternative && q) {
			q = false;
			x.condition = p;
			var s = x.body;
			x.body = x.alternative || m(AST_EmptyStatement);
			x.alternative = s
		}
		if (e(x.body) && e(x.alternative)) {
			return m(AST_SimpleStatement, x.condition, {body: x.condition}).transform(r)
		}
		if (x.body instanceof AST_SimpleStatement && x.alternative instanceof AST_SimpleStatement) {
			return m(AST_SimpleStatement, x, {
				body: m(AST_Conditional, x, {
					condition: x.condition,
					consequent: x.body.body,
					alternative: x.alternative.body
				})
			}).transform(r)
		}
		if (e(x.alternative) && x.body instanceof AST_SimpleStatement) {
			if (q) {
				return m(AST_SimpleStatement, x, {
					body: m(AST_Binary, x, {
						operator: "||",
						left: p,
						right: x.body.body
					})
				}).transform(r)
			}
			return m(AST_SimpleStatement, x, {
				body: m(AST_Binary, x, {
					operator: "&&",
					left: x.condition,
					right: x.body.body
				})
			}).transform(r)
		}
		if (x.body instanceof AST_EmptyStatement && x.alternative && x.alternative instanceof AST_SimpleStatement) {
			return m(AST_SimpleStatement, x, {
				body: m(AST_Binary, x, {
					operator: "||",
					left: x.condition,
					right: x.alternative.body
				})
			}).transform(r)
		}
		if (x.body instanceof AST_Exit && x.alternative instanceof AST_Exit && x.body.TYPE == x.alternative.TYPE) {
			return m(x.body.CTOR, x, {
				value: m(AST_Conditional, x, {
					condition: x.condition,
					consequent: x.body.value || m(AST_Undefined, x.body).optimize(r),
					alternative: x.alternative.value || m(AST_Undefined, x.alternative).optimize(r)
				})
			}).transform(r)
		}
		if (x.body instanceof AST_If && !x.body.alternative && !x.alternative) {
			x.condition = m(AST_Binary, x.condition, {
				operator: "&&",
				left: x.condition,
				right: x.body.condition
			}).transform(r);
			x.body = x.body.body
		}
		if (l(x.body)) {
			if (x.alternative) {
				var t = x.alternative;
				x.alternative = null;
				return m(AST_BlockStatement, x, {body: [x, t]}).transform(r)
			}
		}
		if (l(x.alternative)) {
			var u = x.body;
			x.body = x.alternative;
			x.condition = q ? p : x.condition.negate(r);
			x.alternative = null;
			return m(AST_BlockStatement, x, {body: [x, u]}).transform(r)
		}
		return x
	});
	k(AST_Switch, function (B, s) {
		if (B.body.length == 0 && s.option("conditionals")) {
			return m(AST_SimpleStatement, B, {body: B.expression}).transform(s)
		}
		for (; ;) {
			var x = B.body[B.body.length - 1];
			if (x) {
				var t = x.body[x.body.length - 1];
				if (t instanceof AST_Break && i(s.loopcontrol_target(t.label)) === B) {
					x.body.pop()
				}
				if (x instanceof AST_Default && x.body.length == 0) {
					B.body.pop();
					continue
				}
			}
			break
		}
		var r = B.expression.evaluate(s);
		out:if (r.length == 2) {
			try {
				B.expression = r[0];
				if (!s.option("dead_code")) {
					break out
				}
				var z = r[1];
				var A = false;
				var q = false;
				var w = false;
				var p = false;
				var y = false;
				var u = new TreeTransformer(function (F, C, E) {
					if (F instanceof AST_Lambda || F instanceof AST_SimpleStatement) {
						return F
					} else {
						if (F instanceof AST_Switch && F === B) {
							F = F.clone();
							C(F, this);
							return y ? F : m(AST_BlockStatement, F, {
								body: F.body.reduce(function (H, I) {
									return H.concat(I.body)
								}, [])
							}).transform(s)
						} else {
							if (F instanceof AST_If || F instanceof AST_Try) {
								var D = A;
								A = !q;
								C(F, this);
								A = D;
								return F
							} else {
								if (F instanceof AST_StatementWithBody || F instanceof AST_Switch) {
									var D = q;
									q = true;
									C(F, this);
									q = D;
									return F
								} else {
									if (F instanceof AST_Break && this.loopcontrol_target(F.label) === B) {
										if (A) {
											y = true;
											return F
										}
										if (q) {
											return F
										}
										p = true;
										return E ? MAP.skip : m(AST_EmptyStatement, F)
									} else {
										if (F instanceof AST_SwitchBranch && this.parent() === B) {
											if (p) {
												return MAP.skip
											}
											if (F instanceof AST_Case) {
												var G = F.expression.evaluate(s);
												if (G.length < 2) {
													throw B
												}
												if (G[1] === z || w) {
													w = true;
													if (l(F)) {
														p = true
													}
													C(F, this);
													return F
												}
												return MAP.skip
											}
											C(F, this);
											return F
										}
									}
								}
							}
						}
					}
				});
				u.stack = s.stack.slice();
				B = B.transform(u)
			} catch (v) {
				if (v !== B) {
					throw v
				}
			}
		}
		return B
	});
	k(AST_Case, function (p, q) {
		p.body = h(p.body, q);
		return p
	});
	k(AST_Try, function (p, q) {
		p.body = h(p.body, q);
		return p
	});
	AST_Definitions.DEFMETHOD("remove_initializers", function () {
		this.definitions.forEach(function (p) {
			p.value = null
		})
	});
	AST_Definitions.DEFMETHOD("to_assignments", function () {
		var p = this.definitions.reduce(function (q, s) {
			if (s.value) {
				var r = m(AST_SymbolRef, s.name, s.name);
				q.push(m(AST_Assign, s, {operator: "=", left: r, right: s.value}))
			}
			return q
		}, []);
		if (p.length == 0) {
			return null
		}
		return AST_Seq.from_array(p)
	});
	k(AST_Definitions, function (p, q) {
		if (p.definitions.length == 0) {
			return m(AST_EmptyStatement, p)
		}
		return p
	});
	k(AST_Function, function (p, q) {
		p = AST_Lambda.prototype.optimize.call(p, q);
		if (q.option("unused")) {
			if (p.name && p.name.unreferenced()) {
				p.name = null
			}
		}
		return p
	});
	k(AST_Call, function (B, u) {
		if (u.option("unsafe")) {
			var t = B.expression;
			if (t instanceof AST_SymbolRef && t.undeclared()) {
				switch (t.name) {
					case"Array":
						if (B.args.length != 1) {
							return m(AST_Array, B, {elements: B.args}).transform(u)
						}
						break;
					case"Object":
						if (B.args.length == 0) {
							return m(AST_Object, B, {properties: []})
						}
						break;
					case"String":
						if (B.args.length == 0) {
							return m(AST_String, B, {value: ""})
						}
						if (B.args.length <= 1) {
							return m(AST_Binary, B, {
								left: B.args[0],
								operator: "+",
								right: m(AST_String, B, {value: ""})
							}).transform(u)
						}
						break;
					case"Number":
						if (B.args.length == 0) {
							return m(AST_Number, B, {value: 0})
						}
						if (B.args.length == 1) {
							return m(AST_UnaryPrefix, B, {expression: B.args[0], operator: "+"}).transform(u)
						}
					case"Boolean":
						if (B.args.length == 0) {
							return m(AST_False, B)
						}
						if (B.args.length == 1) {
							return m(AST_UnaryPrefix, B, {
								expression: m(AST_UnaryPrefix, null, {
									expression: B.args[0],
									operator: "!"
								}), operator: "!"
							}).transform(u)
						}
						break;
					case"Function":
						if (all(B.args, function (C) {
								return C instanceof AST_String
							})) {
							try {
								var r = "(function(" + B.args.slice(0, -1).map(function (C) {
										return C.value
									}).join(",") + "){" + B.args[B.args.length - 1].value + "})()";
								var q = parse(r);
								q.figure_out_scope({screw_ie8: u.option("screw_ie8")});
								var x = new Compressor(u.options);
								q = q.transform(x);
								q.figure_out_scope({screw_ie8: u.option("screw_ie8")});
								q.mangle_names();
								var A;
								try {
									q.walk(new TreeWalker(function (C) {
										if (C instanceof AST_Lambda) {
											A = C;
											throw q
										}
									}))
								} catch (z) {
									if (z !== q) {
										throw z
									}
								}
								var y = A.argnames.map(function (C, D) {
									return m(AST_String, B.args[D], {value: C.print_to_string()})
								});
								var r = OutputStream();
								AST_BlockStatement.prototype._codegen.call(A, A, r);
								r = r.toString().replace(/^\{|\}$/g, "");
								y.push(m(AST_String, B.args[B.args.length - 1], {value: r}));
								B.args = y;
								return B
							} catch (z) {
								if (z instanceof JS_Parse_Error) {
									u.warn("Error parsing code passed to new Function [{file}:{line},{col}]", B.args[B.args.length - 1].start);
									u.warn(z.toString())
								} else {
									console.log(z);
									throw z
								}
							}
						}
						break
				}
			} else {
				if (t instanceof AST_Dot && t.property == "toString" && B.args.length == 0) {
					return m(AST_Binary, B, {
						left: m(AST_String, B, {value: ""}),
						operator: "+",
						right: t.expression
					}).transform(u)
				} else {
					if (t instanceof AST_Dot && t.expression instanceof AST_Array && t.property == "join") {
						EXIT:{
							var w = B.args.length == 0 ? "," : B.args[0].evaluate(u)[1];
							if (w == null) {
								break EXIT
							}
							var p = t.expression.elements.reduce(function (C, D) {
								D = D.evaluate(u);
								if (C.length == 0 || D.length == 1) {
									C.push(D)
								} else {
									var E = C[C.length - 1];
									if (E.length == 2) {
										var F = "" + E[1] + w + D[1];
										C[C.length - 1] = [n(u, F, E[0]), F]
									} else {
										C.push(D)
									}
								}
								return C
							}, []);
							if (p.length == 0) {
								return m(AST_String, B, {value: ""})
							}
							if (p.length == 1) {
								return p[0][0]
							}
							if (w == "") {
								var v;
								if (p[0][0] instanceof AST_String || p[1][0] instanceof AST_String) {
									v = p.shift()[0]
								} else {
									v = m(AST_String, B, {value: ""})
								}
								return p.reduce(function (D, C) {
									return m(AST_Binary, C[0], {operator: "+", left: D, right: C[0]})
								}, v).transform(u)
							}
							var s = B.clone();
							s.expression = s.expression.clone();
							s.expression.expression = s.expression.expression.clone();
							s.expression.expression.elements = p.map(function (C) {
								return C[0]
							});
							return f(B, s)
						}
					}
				}
			}
		}
		if (u.option("side_effects")) {
			if (B.expression instanceof AST_Function && B.args.length == 0 && !AST_Block.prototype.has_side_effects.call(B.expression, u)) {
				return m(AST_Undefined, B).transform(u)
			}
		}
		if (u.option("drop_console")) {
			if (B.expression instanceof AST_PropAccess && B.expression.expression instanceof AST_SymbolRef && B.expression.expression.name == "console" && B.expression.expression.undeclared()) {
				return m(AST_Undefined, B).transform(u)
			}
		}
		return B.evaluate(u)[0]
	});
	k(AST_New, function (p, r) {
		if (r.option("unsafe")) {
			var q = p.expression;
			if (q instanceof AST_SymbolRef && q.undeclared()) {
				switch (q.name) {
					case"Object":
					case"RegExp":
					case"Function":
					case"Error":
					case"Array":
						return m(AST_Call, p, p).transform(r)
				}
			}
		}
		return p
	});
	k(AST_Seq, function (q, s) {
		if (!s.option("side_effects")) {
			return q
		}
		if (!q.car.has_side_effects(s)) {
			var r;
			if (!(q.cdr instanceof AST_SymbolRef && q.cdr.name == "eval" && q.cdr.undeclared() && (r = s.parent()) instanceof AST_Call && r.expression === q)) {
				return q.cdr
			}
		}
		if (s.option("cascade")) {
			if (q.car instanceof AST_Assign && !q.car.left.has_side_effects(s)) {
				if (q.car.left.equivalent_to(q.cdr)) {
					return q.car
				}
				if (q.cdr instanceof AST_Call && q.cdr.expression.equivalent_to(q.car.left)) {
					q.cdr.expression = q.car;
					return q.cdr
				}
			}
			if (!q.car.has_side_effects(s) && !q.cdr.has_side_effects(s) && q.car.equivalent_to(q.cdr)) {
				return q.car
			}
		}
		if (q.cdr instanceof AST_UnaryPrefix && q.cdr.operator == "void" && !q.cdr.expression.has_side_effects(s)) {
			q.cdr.operator = q.car;
			return q.cdr
		}
		if (q.cdr instanceof AST_Undefined) {
			return m(AST_UnaryPrefix, q, {operator: "void", expression: q.car})
		}
		return q
	});
	AST_Unary.DEFMETHOD("lift_sequences", function (r) {
		if (r.option("sequences")) {
			if (this.expression instanceof AST_Seq) {
				var q = this.expression;
				var p = q.to_array();
				this.expression = p.pop();
				p.push(this);
				q = AST_Seq.from_array(p).transform(r);
				return q
			}
		}
		return this
	});
	k(AST_UnaryPostfix, function (p, q) {
		return p.lift_sequences(q)
	});
	k(AST_UnaryPrefix, function (p, r) {
		p = p.lift_sequences(r);
		var q = p.expression;
		if (r.option("booleans") && r.in_boolean_context()) {
			switch (p.operator) {
				case"!":
					if (q instanceof AST_UnaryPrefix && q.operator == "!") {
						return q.expression
					}
					break;
				case"typeof":
					r.warn("Boolean expression always true [{file}:{line},{col}]", p.start);
					return m(AST_True, p)
			}
			if (q instanceof AST_Binary && p.operator == "!") {
				p = f(p, q.negate(r))
			}
		}
		return p.evaluate(r)[0]
	});
	function j(q, s) {
		var r = s.option("pure_getters");
		s.options.pure_getters = false;
		var p = q.has_side_effects(s);
		s.options.pure_getters = r;
		return p
	}

	AST_Binary.DEFMETHOD("lift_sequences", function (r) {
		if (r.option("sequences")) {
			if (this.left instanceof AST_Seq) {
				var q = this.left;
				var p = q.to_array();
				this.left = p.pop();
				p.push(this);
				q = AST_Seq.from_array(p).transform(r);
				return q
			}
			if (this.right instanceof AST_Seq && this instanceof AST_Assign && !j(this.left, r)) {
				var q = this.right;
				var p = q.to_array();
				this.right = p.pop();
				p.push(this);
				q = AST_Seq.from_array(p).transform(r);
				return q
			}
		}
		return this
	});
	var d = makePredicate("== === != !== * & | ^");
	k(AST_Binary, function (p, u) {
		var r = u.has_directive("use asm") ? noop : function (x, w) {
			if (w || !(p.left.has_side_effects(u) || p.right.has_side_effects(u))) {
				if (x) {
					p.operator = x
				}
				var v = p.left;
				p.left = p.right;
				p.right = v
			}
		};
		if (d(p.operator)) {
			if (p.right instanceof AST_Constant && !(p.left instanceof AST_Constant)) {
				if (!(p.left instanceof AST_Binary && PRECEDENCE[p.left.operator] >= PRECEDENCE[p.operator])) {
					r(null, true)
				}
			}
			if (/^[!=]==?$/.test(p.operator)) {
				if (p.left instanceof AST_SymbolRef && p.right instanceof AST_Conditional) {
					if (p.right.consequent instanceof AST_SymbolRef && p.right.consequent.definition() === p.left.definition()) {
						if (/^==/.test(p.operator)) {
							return p.right.condition
						}
						if (/^!=/.test(p.operator)) {
							return p.right.condition.negate(u)
						}
					}
					if (p.right.alternative instanceof AST_SymbolRef && p.right.alternative.definition() === p.left.definition()) {
						if (/^==/.test(p.operator)) {
							return p.right.condition.negate(u)
						}
						if (/^!=/.test(p.operator)) {
							return p.right.condition
						}
					}
				}
				if (p.right instanceof AST_SymbolRef && p.left instanceof AST_Conditional) {
					if (p.left.consequent instanceof AST_SymbolRef && p.left.consequent.definition() === p.right.definition()) {
						if (/^==/.test(p.operator)) {
							return p.left.condition
						}
						if (/^!=/.test(p.operator)) {
							return p.left.condition.negate(u)
						}
					}
					if (p.left.alternative instanceof AST_SymbolRef && p.left.alternative.definition() === p.right.definition()) {
						if (/^==/.test(p.operator)) {
							return p.left.condition.negate(u)
						}
						if (/^!=/.test(p.operator)) {
							return p.left.condition
						}
					}
				}
			}
		}
		p = p.lift_sequences(u);
		if (u.option("comparisons")) {
			switch (p.operator) {
				case"===":
				case"!==":
					if ((p.left.is_string(u) && p.right.is_string(u)) || (p.left.is_boolean() && p.right.is_boolean())) {
						p.operator = p.operator.substr(0, 2)
					}
				case"==":
				case"!=":
					if (p.left instanceof AST_String && p.left.value == "undefined" && p.right instanceof AST_UnaryPrefix && p.right.operator == "typeof" && u.option("unsafe")) {
						if (!(p.right.expression instanceof AST_SymbolRef) || !p.right.expression.undeclared()) {
							p.right = p.right.expression;
							p.left = m(AST_Undefined, p.left).optimize(u);
							if (p.operator.length == 2) {
								p.operator += "="
							}
						}
					}
					break
			}
		}
		if (u.option("booleans") && u.in_boolean_context()) {
			switch (p.operator) {
				case"&&":
					var s = p.left.evaluate(u);
					var q = p.right.evaluate(u);
					if ((s.length > 1 && !s[1]) || (q.length > 1 && !q[1])) {
						u.warn("Boolean && always false [{file}:{line},{col}]", p.start);
						return m(AST_False, p)
					}
					if (s.length > 1 && s[1]) {
						return q[0]
					}
					if (q.length > 1 && q[1]) {
						return s[0]
					}
					break;
				case"||":
					var s = p.left.evaluate(u);
					var q = p.right.evaluate(u);
					if ((s.length > 1 && s[1]) || (q.length > 1 && q[1])) {
						u.warn("Boolean || always true [{file}:{line},{col}]", p.start);
						return m(AST_True, p)
					}
					if (s.length > 1 && !s[1]) {
						return q[0]
					}
					if (q.length > 1 && !q[1]) {
						return s[0]
					}
					break;
				case"+":
					var s = p.left.evaluate(u);
					var q = p.right.evaluate(u);
					if ((s.length > 1 && s[0] instanceof AST_String && s[1]) || (q.length > 1 && q[0] instanceof AST_String && q[1])) {
						u.warn("+ in boolean context always true [{file}:{line},{col}]", p.start);
						return m(AST_True, p)
					}
					break
			}
		}
		if (u.option("comparisons")) {
			if (!(u.parent() instanceof AST_Binary) || u.parent() instanceof AST_Assign) {
				var t = m(AST_UnaryPrefix, p, {operator: "!", expression: p.negate(u)});
				p = f(p, t)
			}
			switch (p.operator) {
				case"<":
					r(">");
					break;
				case"<=":
					r(">=");
					break
			}
		}
		if (p.operator == "+" && p.right instanceof AST_String && p.right.getValue() === "" && p.left instanceof AST_Binary && p.left.operator == "+" && p.left.is_string(u)) {
			return p.left
		}
		if (u.option("evaluate")) {
			if (p.operator == "+") {
				if (p.left instanceof AST_Constant && p.right instanceof AST_Binary && p.right.operator == "+" && p.right.left instanceof AST_Constant && p.right.is_string(u)) {
					p = m(AST_Binary, p, {
						operator: "+",
						left: m(AST_String, null, {
							value: "" + p.left.getValue() + p.right.left.getValue(),
							start: p.left.start,
							end: p.right.left.end
						}),
						right: p.right.right
					})
				}
				if (p.right instanceof AST_Constant && p.left instanceof AST_Binary && p.left.operator == "+" && p.left.right instanceof AST_Constant && p.left.is_string(u)) {
					p = m(AST_Binary, p, {
						operator: "+",
						left: p.left.left,
						right: m(AST_String, null, {
							value: "" + p.left.right.getValue() + p.right.getValue(),
							start: p.left.right.start,
							end: p.right.end
						})
					})
				}
				if (p.left instanceof AST_Binary && p.left.operator == "+" && p.left.is_string(u) && p.left.right instanceof AST_Constant && p.right instanceof AST_Binary && p.right.operator == "+" && p.right.left instanceof AST_Constant && p.right.is_string(u)) {
					p = m(AST_Binary, p, {
						operator: "+",
						left: m(AST_Binary, p.left, {
							operator: "+",
							left: p.left.left,
							right: m(AST_String, null, {
								value: "" + p.left.right.getValue() + p.right.left.getValue(),
								start: p.left.right.start,
								end: p.right.left.end
							})
						}),
						right: p.right.right
					})
				}
			}
		}
		if (p.right instanceof AST_Binary && p.right.operator == p.operator && (p.operator == "*" || p.operator == "&&" || p.operator == "||")) {
			p.left = m(AST_Binary, p.left, {operator: p.operator, left: p.left, right: p.right.left});
			p.right = p.right.right;
			return p.transform(u)
		}
		return p.evaluate(u)[0]
	});
	k(AST_SymbolRef, function (p, r) {
		if (p.undeclared()) {
			var q = r.option("global_defs");
			if (q && q.hasOwnProperty(p.name)) {
				return n(r, q[p.name], p)
			}
			switch (p.name) {
				case"undefined":
					return m(AST_Undefined, p);
				case"NaN":
					return m(AST_NaN, p);
				case"Infinity":
					return m(AST_Infinity, p)
			}
		}
		return p
	});
	k(AST_Undefined, function (p, t) {
		if (t.option("unsafe")) {
			var r = t.find_parent(AST_Scope);
			var q = r.find_variable("undefined");
			if (q) {
				var s = m(AST_SymbolRef, p, {name: "undefined", scope: r, thedef: q});
				s.reference();
				return s
			}
		}
		return p
	});
	var c = ["+", "-", "/", "*", "%", ">>", "<<", ">>>", "|", "^", "&"];
	k(AST_Assign, function (p, q) {
		p = p.lift_sequences(q);
		if (p.operator == "=" && p.left instanceof AST_SymbolRef && p.right instanceof AST_Binary && p.right.left instanceof AST_SymbolRef && p.right.left.name == p.left.name && member(p.right.operator, c)) {
			p.operator = p.right.operator + "=";
			p.right = p.right.right
		}
		return p
	});
	k(AST_Conditional, function (q, v) {
		if (!v.option("conditionals")) {
			return q
		}
		if (q.condition instanceof AST_Seq) {
			var p = q.condition.car;
			q.condition = q.condition.cdr;
			return AST_Seq.cons(p, q)
		}
		var s = q.condition.evaluate(v);
		if (s.length > 1) {
			if (s[1]) {
				v.warn("Condition always true [{file}:{line},{col}]", q.start);
				return q.consequent
			} else {
				v.warn("Condition always false [{file}:{line},{col}]", q.start);
				return q.alternative
			}
		}
		var u = s[0].negate(v);
		if (f(s[0], u) === u) {
			q = m(AST_Conditional, q, {condition: u, consequent: q.alternative, alternative: q.consequent})
		}
		var t = q.consequent;
		var r = q.alternative;
		if (t instanceof AST_Assign && r instanceof AST_Assign && t.operator == r.operator && t.left.equivalent_to(r.left)) {
			return m(AST_Assign, q, {
				operator: t.operator,
				left: t.left,
				right: m(AST_Conditional, q, {condition: q.condition, consequent: t.right, alternative: r.right})
			})
		}
		if (t instanceof AST_Call && r.TYPE === t.TYPE && t.args.length == r.args.length && t.expression.equivalent_to(r.expression)) {
			if (t.args.length == 0) {
				return m(AST_Seq, q, {car: q.condition, cdr: t})
			}
			if (t.args.length == 1) {
				t.args[0] = m(AST_Conditional, q, {
					condition: q.condition,
					consequent: t.args[0],
					alternative: r.args[0]
				});
				return t
			}
		}
		if (t instanceof AST_Conditional && t.alternative.equivalent_to(r)) {
			return m(AST_Conditional, q, {
				condition: m(AST_Binary, q, {
					left: q.condition,
					operator: "&&",
					right: t.condition
				}), consequent: t.consequent, alternative: r
			})
		}
		return q
	});
	k(AST_Boolean, function (q, s) {
		if (s.option("booleans")) {
			var r = s.parent();
			if (r instanceof AST_Binary && (r.operator == "==" || r.operator == "!=")) {
				s.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
					operator: r.operator,
					value: q.value,
					file: r.start.file,
					line: r.start.line,
					col: r.start.col
				});
				return m(AST_Number, q, {value: +q.value})
			}
			return m(AST_UnaryPrefix, q, {operator: "!", expression: m(AST_Number, q, {value: 1 - q.value})})
		}
		return q
	});
	k(AST_Sub, function (q, s) {
		var r = q.property;
		if (r instanceof AST_String && s.option("properties")) {
			r = r.getValue();
			if (RESERVED_WORDS(r) ? s.option("screw_ie8") : is_identifier_string(r)) {
				return m(AST_Dot, q, {expression: q.expression, property: r}).optimize(s)
			}
			var p = parseFloat(r);
			if (!isNaN(p) && p.toString() == r) {
				q.property = m(AST_Number, q.property, {value: p})
			}
		}
		return q
	});
	k(AST_Dot, function (p, q) {
		return p.evaluate(q)[0]
	});
	function a(p, q) {
		if (q.option("booleans") && q.in_boolean_context()) {
			return m(AST_True, p)
		}
		return p
	}

	k(AST_Array, a);
	k(AST_Object, a);
	k(AST_RegExp, a)
})();
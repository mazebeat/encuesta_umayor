"use strict";
(function () {
	var f = {
		TryStatement: function (i) {
			return new AST_Try({
				start: b(i),
				end: a(i),
				body: h(i.block).body,
				bcatch: h(i.handlers ? i.handlers[0] : i.handler),
				bfinally: i.finalizer ? new AST_Finally(h(i.finalizer)) : null
			})
		}, CatchClause: function (i) {
			return new AST_Catch({start: b(i), end: a(i), argname: h(i.param), body: h(i.body).body})
		}, ObjectExpression: function (i) {
			return new AST_Object({
				start: b(i), end: a(i), properties: i.properties.map(function (m) {
					var l = m.key;
					var k = l.type == "Identifier" ? l.name : l.value;
					var j = {start: b(l), end: a(m.value), key: k, value: h(m.value)};
					switch (m.kind) {
						case"init":
							return new AST_ObjectKeyVal(j);
						case"set":
							j.value.name = h(l);
							return new AST_ObjectSetter(j);
						case"get":
							j.value.name = h(l);
							return new AST_ObjectGetter(j)
					}
				})
			})
		}, SequenceExpression: function (i) {
			return AST_Seq.from_array(i.expressions.map(h))
		}, MemberExpression: function (i) {
			return new (i.computed ? AST_Sub : AST_Dot)({
				start: b(i),
				end: a(i),
				property: i.computed ? h(i.property) : i.property.name,
				expression: h(i.object)
			})
		}, SwitchCase: function (i) {
			return new (i.test ? AST_Case : AST_Default)({
				start: b(i),
				end: a(i),
				expression: h(i.test),
				body: i.consequent.map(h)
			})
		}, Literal: function (k) {
			var j = k.value, i = {start: b(k), end: a(k)};
			if (j === null) {
				return new AST_Null(i)
			}
			switch (typeof j) {
				case"string":
					i.value = j;
					return new AST_String(i);
				case"number":
					i.value = j;
					return new AST_Number(i);
				case"boolean":
					return new (j ? AST_True : AST_False)(i);
				default:
					i.value = j;
					return new AST_RegExp(i)
			}
		}, UnaryExpression: e, UpdateExpression: e, Identifier: function (j) {
			var i = d[d.length - 2];
			return new (j.name == "this" ? AST_This : i.type == "LabeledStatement" ? AST_Label : i.type == "VariableDeclarator" && i.id === j ? (i.kind == "const" ? AST_SymbolConst : AST_SymbolVar) : i.type == "FunctionExpression" ? (i.id === j ? AST_SymbolLambda : AST_SymbolFunarg) : i.type == "FunctionDeclaration" ? (i.id === j ? AST_SymbolDefun : AST_SymbolFunarg) : i.type == "CatchClause" ? AST_SymbolCatch : i.type == "BreakStatement" || i.type == "ContinueStatement" ? AST_LabelRef : AST_SymbolRef)({
				start: b(j),
				end: a(j),
				name: j.name
			})
		}
	};

	function e(j) {
		var i = "prefix" in j ? j.prefix : j.type == "UnaryExpression" ? true : false;
		return new (i ? AST_UnaryPrefix : AST_UnaryPostfix)({
			start: b(j),
			end: a(j),
			operator: j.operator,
			expression: h(j.argument)
		})
	}

	var c = {};
	g("Node", AST_Node);
	g("Program", AST_Toplevel, "body@body");
	g("Function", AST_Function, "id>name, params@argnames, body%body");
	g("EmptyStatement", AST_EmptyStatement);
	g("BlockStatement", AST_BlockStatement, "body@body");
	g("ExpressionStatement", AST_SimpleStatement, "expression>body");
	g("IfStatement", AST_If, "test>condition, consequent>body, alternate>alternative");
	g("LabeledStatement", AST_LabeledStatement, "label>label, body>body");
	g("BreakStatement", AST_Break, "label>label");
	g("ContinueStatement", AST_Continue, "label>label");
	g("WithStatement", AST_With, "object>expression, body>body");
	g("SwitchStatement", AST_Switch, "discriminant>expression, cases@body");
	g("ReturnStatement", AST_Return, "argument>value");
	g("ThrowStatement", AST_Throw, "argument>value");
	g("WhileStatement", AST_While, "test>condition, body>body");
	g("DoWhileStatement", AST_Do, "test>condition, body>body");
	g("ForStatement", AST_For, "init>init, test>condition, update>step, body>body");
	g("ForInStatement", AST_ForIn, "left>init, right>object, body>body");
	g("DebuggerStatement", AST_Debugger);
	g("FunctionDeclaration", AST_Defun, "id>name, params@argnames, body%body");
	g("VariableDeclaration", AST_Var, "declarations@definitions");
	g("VariableDeclarator", AST_VarDef, "id>name, init>value");
	g("ThisExpression", AST_This);
	g("ArrayExpression", AST_Array, "elements@elements");
	g("FunctionExpression", AST_Function, "id>name, params@argnames, body%body");
	g("BinaryExpression", AST_Binary, "operator=operator, left>left, right>right");
	g("AssignmentExpression", AST_Assign, "operator=operator, left>left, right>right");
	g("LogicalExpression", AST_Binary, "operator=operator, left>left, right>right");
	g("ConditionalExpression", AST_Conditional, "test>condition, consequent>consequent, alternate>alternative");
	g("NewExpression", AST_New, "callee>expression, arguments@args");
	g("CallExpression", AST_Call, "callee>expression, arguments@args");
	function b(i) {
		return new AST_Token({
			file: i.loc && i.loc.source,
			line: i.loc && i.loc.start.line,
			col: i.loc && i.loc.start.column,
			pos: i.start,
			endpos: i.start
		})
	}

	function a(i) {
		return new AST_Token({
			file: i.loc && i.loc.source,
			line: i.loc && i.loc.end.line,
			col: i.loc && i.loc.end.column,
			pos: i.end,
			endpos: i.end
		})
	}

	function g(i, l, j) {
		var k = "function From_Moz_" + i + "(M){\n";
		k += "return new mytype({\nstart: my_start_token(M),\nend: my_end_token(M)";
		if (j) {
			j.split(/\s*,\s*/).forEach(function (r) {
				var n = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(r);
				if (!n) {
					throw new Error("Can't understand property map: " + r)
				}
				var o = "M." + n[1], p = n[2], q = n[3];
				k += ",\n" + q + ": ";
				if (p == "@") {
					k += o + ".map(from_moz)"
				} else {
					if (p == ">") {
						k += "from_moz(" + o + ")"
					} else {
						if (p == "=") {
							k += o
						} else {
							if (p == "%") {
								k += "from_moz(" + o + ").body"
							} else {
								throw new Error("Can't understand operator in propmap: " + r)
							}
						}
					}
				}
			})
		}
		k += "\n})}";
		k = new Function("mytype", "my_start_token", "my_end_token", "from_moz", "return(" + k + ")")(l, b, a, h);
		return f[i] = k
	}

	var d = null;

	function h(j) {
		d.push(j);
		var i = j != null ? f[j.type](j) : null;
		d.pop();
		return i
	}

	AST_Node.from_mozilla_ast = function (j) {
		var k = d;
		d = [];
		var i = h(j);
		d = k;
		return i
	}
})();
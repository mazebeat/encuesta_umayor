"use strict";
var KEYWORDS = "break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with";
var KEYWORDS_ATOM = "false null true";
var RESERVED_WORDS = "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile yield " + KEYWORDS_ATOM + " " + KEYWORDS;
var KEYWORDS_BEFORE_EXPRESSION = "return new delete throw else case";
KEYWORDS = makePredicate(KEYWORDS);
RESERVED_WORDS = makePredicate(RESERVED_WORDS);
KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);
var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));
var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
var RE_OCT_NUMBER = /^0[0-7]+$/;
var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;
var OPERATORS = makePredicate(["in", "instanceof", "typeof", "new", "void", "delete", "++", "--", "+", "-", "!", "~", "&", "|", "^", "*", "/", "%", ">>", "<<", ">>>", "<", ">", "<=", ">=", "==", "===", "!=", "!==", "?", "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=", "&&", "||"]);
var WHITESPACE_CHARS = makePredicate(characters(" \u00a0\n\r\t\f\u000b\u200b\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000"));
var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,.;:"));
var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));
var REGEXP_MODIFIERS = makePredicate(characters("gmsiy"));
var UNICODE = {
	letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
	non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
	space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
	connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")
};
function is_letter(a) {
	return (a >= 97 && a <= 122) || (a >= 65 && a <= 90) || (a >= 170 && UNICODE.letter.test(String.fromCharCode(a)))
}
function is_digit(a) {
	return a >= 48 && a <= 57
}
function is_alphanumeric_char(a) {
	return is_digit(a) || is_letter(a)
}
function is_unicode_combining_mark(a) {
	return UNICODE.non_spacing_mark.test(a) || UNICODE.space_combining_mark.test(a)
}
function is_unicode_connector_punctuation(a) {
	return UNICODE.connector_punctuation.test(a)
}
function is_identifier(a) {
	return !RESERVED_WORDS(a) && /^[a-z_$][a-z0-9_$]*$/i.test(a)
}
function is_identifier_start(a) {
	return a == 36 || a == 95 || is_letter(a)
}
function is_identifier_char(a) {
	var b = a.charCodeAt(0);
	return is_identifier_start(b) || is_digit(b) || b == 8204 || b == 8205 || is_unicode_combining_mark(a) || is_unicode_connector_punctuation(a)
}
function is_identifier_string(a) {
	return /^[a-z_$][a-z0-9_$]*$/i.test(a)
}
function parse_js_number(a) {
	if (RE_HEX_NUMBER.test(a)) {
		return parseInt(a.substr(2), 16)
	} else {
		if (RE_OCT_NUMBER.test(a)) {
			return parseInt(a.substr(1), 8)
		} else {
			if (RE_DEC_NUMBER.test(a)) {
				return parseFloat(a)
			}
		}
	}
}
function JS_Parse_Error(c, a, b, d) {
	this.message = c;
	this.line = a;
	this.col = b;
	this.pos = d;
	this.stack = new Error().stack
}
JS_Parse_Error.prototype.toString = function () {
	return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")\n\n" + this.stack
};
function js_error(d, b, a, c, e) {
	throw new JS_Parse_Error(d, a, c, e)
}
function is_token(a, b, c) {
	return a.type == b && (c == null || a.value == c)
}
var EX_EOF = {};
function tokenizer(b, w, n) {
	var f = {
		text: b.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\uFEFF/g, ""),
		filename: w,
		pos: 0,
		tokpos: 0,
		line: 1,
		tokline: 0,
		col: 0,
		tokcol: 0,
		newline_before: false,
		regex_allowed: false,
		comments_before: []
	};

	function u() {
		return f.text.charAt(f.pos)
	}

	function t(D, E) {
		var F = f.text.charAt(f.pos++);
		if (D && !F) {
			throw EX_EOF
		}
		if (F == "\n") {
			f.newline_before = f.newline_before || !E;
			++f.line;
			f.col = 0
		} else {
			++f.col
		}
		return F
	}

	function o(D) {
		while (D-- > 0) {
			t()
		}
	}

	function y(D) {
		return f.text.substr(f.pos, D.length) == D
	}

	function r(E, D) {
		var F = f.text.indexOf(E, f.pos);
		if (D && F == -1) {
			throw EX_EOF
		}
		return F
	}

	function q() {
		f.tokline = f.line;
		f.tokcol = f.col;
		f.tokpos = f.pos
	}

	var B = false;

	function j(H, I, G) {
		f.regex_allowed = ((H == "operator" && !UNARY_POSTFIX(I)) || (H == "keyword" && KEYWORDS_BEFORE_EXPRESSION(I)) || (H == "punc" && PUNC_BEFORE_EXPRESSION(I)));
		B = (H == "punc" && I == ".");
		var E = {
			type: H,
			value: I,
			line: f.tokline,
			col: f.tokcol,
			pos: f.tokpos,
			endpos: f.pos,
			nlb: f.newline_before,
			file: w
		};
		if (!G) {
			E.comments_before = f.comments_before;
			f.comments_before = [];
			for (var F = 0, D = E.comments_before.length; F < D; F++) {
				E.nlb = E.nlb || E.comments_before[F].nlb
			}
		}
		f.newline_before = false;
		return new AST_Token(E)
	}

	function C() {
		while (WHITESPACE_CHARS(u())) {
			t()
		}
	}

	function l(D) {
		var E = "", G, F = 0;
		while ((G = u()) && D(G, F++)) {
			E += t()
		}
		return E
	}

	function v(D) {
		js_error(D, w, f.tokline, f.tokcol, f.tokpos)
	}

	function p(I) {
		var G = false, E = false, J = false, D = I == ".";
		var F = l(function (L, K) {
			var M = L.charCodeAt(0);
			switch (M) {
				case 120:
				case 88:
					return J ? false : (J = true);
				case 101:
				case 69:
					return J ? true : G ? false : (G = E = true);
				case 45:
					return E || (K == 0 && !I);
				case 43:
					return E;
				case (E = false, 46):
					return (!D && !J && !G) ? (D = true) : false
			}
			return is_alphanumeric_char(M)
		});
		if (I) {
			F = I + F
		}
		var H = parse_js_number(F);
		if (!isNaN(H)) {
			return j("num", H)
		} else {
			v("Invalid syntax: " + F)
		}
	}

	function s(D) {
		var E = t(true, D);
		switch (E.charCodeAt(0)) {
			case 110:
				return "\n";
			case 114:
				return "\r";
			case 116:
				return "\t";
			case 98:
				return "\b";
			case 118:
				return "\u000b";
			case 102:
				return "\f";
			case 48:
				return "\0";
			case 120:
				return String.fromCharCode(k(2));
			case 117:
				return String.fromCharCode(k(4));
			case 10:
				return "";
			default:
				return E
		}
	}

	function k(F) {
		var D = 0;
		for (; F > 0; --F) {
			var E = parseInt(t(true), 16);
			if (isNaN(E)) {
				v("Invalid hex-character pattern in string")
			}
			D = (D << 4) | E
		}
		return D
	}

	var e = g("Unterminated string constant", function () {
		var D = t(), E = "";
		for (; ;) {
			var F = t(true);
			if (F == "\\") {
				var H = 0, G = null;
				F = l(function (I) {
					if (I >= "0" && I <= "7") {
						if (!G) {
							G = I;
							return ++H
						} else {
							if (G <= "3" && H <= 2) {
								return ++H
							} else {
								if (G >= "4" && H <= 1) {
									return ++H
								}
							}
						}
					}
					return false
				});
				if (H > 0) {
					F = String.fromCharCode(parseInt(F, 8))
				} else {
					F = s(true)
				}
			} else {
				if (F == D) {
					break
				}
			}
			E += F
		}
		return j("string", E)
	});

	function x(G) {
		var E = f.regex_allowed;
		var F = r("\n"), D;
		if (F == -1) {
			D = f.text.substr(f.pos);
			f.pos = f.text.length
		} else {
			D = f.text.substring(f.pos, F);
			f.pos = F
		}
		f.comments_before.push(j(G, D, true));
		f.regex_allowed = E;
		return m()
	}

	var A = g("Unterminated multiline comment", function () {
		var E = f.regex_allowed;
		var F = r("*/", true);
		var H = f.text.substring(f.pos, F);
		var D = H.split("\n"), I = D.length;
		f.pos = F + 2;
		f.line += I - 1;
		if (I > 1) {
			f.col = D[I - 1].length
		} else {
			f.col += D[I - 1].length
		}
		f.col += 2;
		var G = f.newline_before = f.newline_before || H.indexOf("\n") >= 0;
		f.comments_before.push(j("comment2", H, true));
		f.regex_allowed = E;
		f.newline_before = G;
		return m()
	});

	function i() {
		var H = false, D = "", E, G = false, F;
		while ((E = u()) != null) {
			if (!H) {
				if (E == "\\") {
					G = H = true, t()
				} else {
					if (is_identifier_char(E)) {
						D += t()
					} else {
						break
					}
				}
			} else {
				if (E != "u") {
					v("Expecting UnicodeEscapeSequence -- uXXXX")
				}
				E = s();
				if (!is_identifier_char(E)) {
					v("Unicode char: " + E.charCodeAt(0) + " is not valid in identifier")
				}
				D += E;
				H = false
			}
		}
		if (KEYWORDS(D) && G) {
			F = D.charCodeAt(0).toString(16).toUpperCase();
			D = "\\u" + "0000".substr(F.length) + F + D.slice(1)
		}
		return D
	}

	var c = g("Unterminated regular expression", function (G) {
		var D = false, E, H = false;
		while ((E = t(true))) {
			if (D) {
				G += "\\" + E;
				D = false
			} else {
				if (E == "[") {
					H = true;
					G += E
				} else {
					if (E == "]" && H) {
						H = false;
						G += E
					} else {
						if (E == "/" && !H) {
							break
						} else {
							if (E == "\\") {
								D = true
							} else {
								G += E
							}
						}
					}
				}
			}
		}
		var F = i();
		return j("regexp", new RegExp(G, F))
	});

	function z(D) {
		function E(G) {
			if (!u()) {
				return G
			}
			var F = G + u();
			if (OPERATORS(F)) {
				t();
				return E(F)
			} else {
				return G
			}
		}

		return j("operator", E(D || t()))
	}

	function h() {
		t();
		switch (u()) {
			case"/":
				t();
				return x("comment1");
			case"*":
				t();
				return A()
		}
		return f.regex_allowed ? c("") : z("/")
	}

	function a() {
		t();
		return is_digit(u().charCodeAt(0)) ? p(".") : j("punc", ".")
	}

	function d() {
		var D = i();
		if (B) {
			return j("name", D)
		}
		return KEYWORDS_ATOM(D) ? j("atom", D) : !KEYWORDS(D) ? j("name", D) : OPERATORS(D) ? j("operator", D) : j("keyword", D)
	}

	function g(E, D) {
		return function (F) {
			try {
				return D(F)
			} catch (G) {
				if (G === EX_EOF) {
					v(E)
				} else {
					throw G
				}
			}
		}
	}

	function m(F) {
		if (F != null) {
			return c(F)
		}
		C();
		q();
		if (n) {
			if (y("<!--")) {
				o(4);
				return x("comment3")
			}
			if (y("-->") && f.newline_before) {
				o(3);
				return x("comment4")
			}
		}
		var D = u();
		if (!D) {
			return j("eof")
		}
		var E = D.charCodeAt(0);
		switch (E) {
			case 34:
			case 39:
				return e();
			case 46:
				return a();
			case 47:
				return h()
		}
		if (is_digit(E)) {
			return p()
		}
		if (PUNC_CHARS(D)) {
			return j("punc", t())
		}
		if (OPERATOR_CHARS(D)) {
			return z()
		}
		if (E == 92 || is_identifier_start(E)) {
			return d()
		}
		v("Unexpected character '" + D + "'")
	}

	m.context = function (D) {
		if (D) {
			f = D
		}
		return f
	};
	return m
}
var UNARY_PREFIX = makePredicate(["typeof", "void", "delete", "--", "++", "!", "~", "-", "+"]);
var UNARY_POSTFIX = makePredicate(["--", "++"]);
var ASSIGNMENT = makePredicate(["=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="]);
var PRECEDENCE = (function (d, f) {
	for (var g = 0; g < d.length; ++g) {
		var c = d[g];
		for (var e = 0; e < c.length; ++e) {
			f[c[e]] = g + 1
		}
	}
	return f
})([["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"]], {});
var STATEMENTS_WITH_LABELS = array_to_hash(["for", "do", "while", "switch"]);
var ATOMIC_START_TOKEN = array_to_hash(["atom", "num", "string", "regexp", "name"]);
function parse(e, s) {
	s = defaults(s, {strict: false, filename: null, toplevel: null, expression: false, html5_comments: true});
	var k = {
		input: (typeof e == "string" ? tokenizer(e, s.filename, s.html5_comments) : e),
		token: null,
		prev: null,
		peeked: null,
		in_function: 0,
		in_directives: true,
		in_loop: 0,
		labels: []
	};
	k.token = i();
	function v(S, ab) {
		return is_token(k.token, S, ab)
	}

	function m() {
		return k.peeked || (k.peeked = k.input())
	}

	function i() {
		k.prev = k.token;
		if (k.peeked) {
			k.token = k.peeked;
			k.peeked = null
		} else {
			k.token = k.input()
		}
		k.in_directives = k.in_directives && (k.token.type == "string" || v("punc", ";"));
		return k.token
	}

	function z() {
		return k.prev
	}

	function h(ad, ab, ac, ae) {
		var S = k.input.context();
		js_error(ad, S.filename, ab != null ? ab : S.tokline, ac != null ? ac : S.tokcol, ae != null ? ae : S.tokpos)
	}

	function c(S, ab) {
		h(ab, S.line, S.col)
	}

	function J(S) {
		if (S == null) {
			S = k.token
		}
		c(S, "Unexpected token: " + S.type + " (" + S.value + ")")
	}

	function u(S, ab) {
		if (v(S, ab)) {
			return i()
		}
		c(k.token, "Unexpected token " + k.token.type + " «" + k.token.value + "», expected " + S + " «" + ab + "»")
	}

	function d(S) {
		return u("punc", S)
	}

	function B() {
		return !s.strict && (k.token.nlb || v("eof") || v("punc", "}"))
	}

	function V() {
		if (v("punc", ";")) {
			i()
		} else {
			if (!B()) {
				J()
			}
		}
	}

	function l() {
		d("(");
		var S = r(true);
		d(")");
		return S
	}

	function g(S) {
		return function () {
			var ad = k.token;
			var ac = S();
			var ab = z();
			ac.start = ad;
			ac.end = ab;
			return ac
		}
	}

	function y() {
		if (v("operator", "/") || v("operator", "/=")) {
			k.peeked = null;
			k.token = k.input(k.token.value.substr(1))
		}
	}

	var t = g(function () {
		var ab;
		y();
		switch (k.token.type) {
			case"string":
				var S = k.in_directives, ac = p();
				if (S && ac.body instanceof AST_String && !v("punc", ",")) {
					return new AST_Directive({value: ac.body.value})
				}
				return ac;
			case"num":
			case"regexp":
			case"operator":
			case"atom":
				return p();
			case"name":
				return is_token(m(), "punc", ":") ? T() : p();
			case"punc":
				switch (k.token.value) {
					case"{":
						return new AST_BlockStatement({start: k.token, body: o(), end: z()});
					case"[":
					case"(":
						return p();
					case";":
						i();
						return new AST_EmptyStatement();
					default:
						J()
				}
			case"keyword":
				switch (ab = k.token.value, i(), ab) {
					case"break":
						return W(AST_Break);
					case"continue":
						return W(AST_Continue);
					case"debugger":
						V();
						return new AST_Debugger();
					case"do":
						return new AST_Do({body: j(t), condition: (u("keyword", "while"), ab = l(), V(), ab)});
					case"while":
						return new AST_While({condition: l(), body: j(t)});
					case"for":
						return L();
					case"function":
						return A(AST_Defun);
					case"if":
						return w();
					case"return":
						if (k.in_function == 0) {
							h("'return' outside of function")
						}
						return new AST_Return({value: (v("punc", ";") ? (i(), null) : B() ? null : (ab = r(true), V(), ab))});
					case"switch":
						return new AST_Switch({expression: l(), body: j(N)});
					case"throw":
						if (k.token.nlb) {
							h("Illegal newline after 'throw'")
						}
						return new AST_Throw({value: (ab = r(true), V(), ab)});
					case"try":
						return R();
					case"var":
						return ab = a(), V(), ab;
					case"const":
						return ab = I(), V(), ab;
					case"with":
						return new AST_With({expression: l(), body: t()});
					default:
						J()
				}
		}
	});

	function T() {
		var S = M(AST_Label);
		if (find_if(function (ac) {
				return ac.name == S.name
			}, k.labels)) {
			h("Label " + S.name + " defined twice")
		}
		d(":");
		k.labels.push(S);
		var ab = t();
		k.labels.pop();
		if (!(ab instanceof AST_IterationStatement)) {
			S.references.forEach(function (ac) {
				if (ac instanceof AST_Continue) {
					ac = ac.label.start;
					h("Continue label `" + S.name + "` refers to non-IterationStatement.", ac.line, ac.col, ac.pos)
				}
			})
		}
		return new AST_LabeledStatement({body: ab, label: S})
	}

	function p(S) {
		return new AST_SimpleStatement({body: (S = r(true), V(), S)})
	}

	function W(ad) {
		var ab = null, S;
		if (!B()) {
			ab = M(AST_LabelRef, true)
		}
		if (ab != null) {
			S = find_if(function (ae) {
				return ae.name == ab.name
			}, k.labels);
			if (!S) {
				h("Undefined label " + ab.name)
			}
			ab.thedef = S
		} else {
			if (k.in_loop == 0) {
				h(ad.TYPE + " not inside a loop or switch")
			}
		}
		V();
		var ac = new ad({label: ab});
		if (S) {
			S.references.push(ac)
		}
		return ac
	}

	function L() {
		d("(");
		var S = null;
		if (!v("punc", ";")) {
			S = v("keyword", "var") ? (i(), a(true)) : r(true, true);
			if (v("operator", "in")) {
				if (S instanceof AST_Var && S.definitions.length > 1) {
					h("Only one variable declaration allowed in for..in loop")
				}
				i();
				return D(S)
			}
		}
		return H(S)
	}

	function H(ab) {
		d(";");
		var ac = v("punc", ";") ? null : r(true);
		d(";");
		var S = v("punc", ")") ? null : r(true);
		d(")");
		return new AST_For({init: ab, condition: ac, step: S, body: j(t)})
	}

	function D(ac) {
		var S = ac instanceof AST_Var ? ac.definitions[0].name : null;
		var ab = r(true);
		d(")");
		return new AST_ForIn({init: ac, name: S, object: ab, body: j(t)})
	}

	var A = function (ac) {
		var S = ac === AST_Defun;
		var ab = v("name") ? M(S ? AST_SymbolDefun : AST_SymbolLambda) : null;
		if (S && !ab) {
			J()
		}
		d("(");
		return new ac({
			name: ab, argnames: (function (ae, ad) {
				while (!v("punc", ")")) {
					if (ae) {
						ae = false
					} else {
						d(",")
					}
					ad.push(M(AST_SymbolFunarg))
				}
				i();
				return ad
			})(true, []), body: (function (ae, af) {
				++k.in_function;
				k.in_directives = true;
				k.in_loop = 0;
				k.labels = [];
				var ad = o();
				--k.in_function;
				k.in_loop = ae;
				k.labels = af;
				return ad
			})(k.in_loop, k.labels)
		})
	};

	function w() {
		var ac = l(), S = t(), ab = null;
		if (v("keyword", "else")) {
			i();
			ab = t()
		}
		return new AST_If({condition: ac, body: S, alternative: ab})
	}

	function o() {
		d("{");
		var S = [];
		while (!v("punc", "}")) {
			if (v("eof")) {
				J()
			}
			S.push(t())
		}
		i();
		return S
	}

	function N() {
		d("{");
		var S = [], ad = null, ac = null, ab;
		while (!v("punc", "}")) {
			if (v("eof")) {
				J()
			}
			if (v("keyword", "case")) {
				if (ac) {
					ac.end = z()
				}
				ad = [];
				ac = new AST_Case({start: (ab = k.token, i(), ab), expression: r(true), body: ad});
				S.push(ac);
				d(":")
			} else {
				if (v("keyword", "default")) {
					if (ac) {
						ac.end = z()
					}
					ad = [];
					ac = new AST_Default({start: (ab = k.token, i(), d(":"), ab), body: ad});
					S.push(ac)
				} else {
					if (!ad) {
						J()
					}
					ad.push(t())
				}
			}
		}
		if (ac) {
			ac.end = z()
		}
		i();
		return S
	}

	function R() {
		var S = o(), ab = null, ad = null;
		if (v("keyword", "catch")) {
			var ae = k.token;
			i();
			d("(");
			var ac = M(AST_SymbolCatch);
			d(")");
			ab = new AST_Catch({start: ae, argname: ac, body: o(), end: z()})
		}
		if (v("keyword", "finally")) {
			var ae = k.token;
			i();
			ad = new AST_Finally({start: ae, body: o(), end: z()})
		}
		if (!ab && !ad) {
			h("Missing catch/finally blocks")
		}
		return new AST_Try({body: S, bcatch: ab, bfinally: ad})
	}

	function b(ac, ab) {
		var S = [];
		for (; ;) {
			S.push(new AST_VarDef({
				start: k.token,
				name: M(ab ? AST_SymbolConst : AST_SymbolVar),
				value: v("operator", "=") ? (i(), r(false, ac)) : null,
				end: z()
			}));
			if (!v("punc", ",")) {
				break
			}
			i()
		}
		return S
	}

	var a = function (S) {
		return new AST_Var({start: z(), definitions: b(S, false), end: z()})
	};
	var I = function () {
		return new AST_Const({start: z(), definitions: b(false, true), end: z()})
	};
	var C = function () {
		var ac = k.token;
		u("operator", "new");
		var ab = x(false), S;
		if (v("punc", "(")) {
			i();
			S = Y(")")
		} else {
			S = []
		}
		return E(new AST_New({start: ac, expression: ab, args: S, end: z()}), true)
	};

	function K() {
		var S = k.token, ab;
		switch (S.type) {
			case"name":
			case"keyword":
				ab = Q(AST_SymbolRef);
				break;
			case"num":
				ab = new AST_Number({start: S, end: S, value: S.value});
				break;
			case"string":
				ab = new AST_String({start: S, end: S, value: S.value});
				break;
			case"regexp":
				ab = new AST_RegExp({start: S, end: S, value: S.value});
				break;
			case"atom":
				switch (S.value) {
					case"false":
						ab = new AST_False({start: S, end: S});
						break;
					case"true":
						ab = new AST_True({start: S, end: S});
						break;
					case"null":
						ab = new AST_Null({start: S, end: S});
						break
				}
				break
		}
		i();
		return ab
	}

	var x = function (S) {
		if (v("operator", "new")) {
			return C()
		}
		var ad = k.token;
		if (v("punc")) {
			switch (ad.value) {
				case"(":
					i();
					var ab = r(true);
					ab.start = ad;
					ab.end = k.token;
					d(")");
					return E(ab, S);
				case"[":
					return E(U(), S);
				case"{":
					return E(aa(), S)
			}
			J()
		}
		if (v("keyword", "function")) {
			i();
			var ac = A(AST_Function);
			ac.start = ad;
			ac.end = z();
			return E(ac, S)
		}
		if (ATOMIC_START_TOKEN[k.token.type]) {
			return E(K(), S)
		}
		J()
	};

	function Y(ac, S, ad) {
		var ae = true, ab = [];
		while (!v("punc", ac)) {
			if (ae) {
				ae = false
			} else {
				d(",")
			}
			if (S && v("punc", ac)) {
				break
			}
			if (v("punc", ",") && ad) {
				ab.push(new AST_Hole({start: k.token, end: k.token}))
			} else {
				ab.push(r(false))
			}
		}
		i();
		return ab
	}

	var U = g(function () {
		d("[");
		return new AST_Array({elements: Y("]", !s.strict, true)})
	});
	var aa = g(function () {
		d("{");
		var ad = true, S = [];
		while (!v("punc", "}")) {
			if (ad) {
				ad = false
			} else {
				d(",")
			}
			if (!s.strict && v("punc", "}")) {
				break
			}
			var ae = k.token;
			var ac = ae.type;
			var ab = q();
			if (ac == "name" && !v("punc", ":")) {
				if (ab == "get") {
					S.push(new AST_ObjectGetter({start: ae, key: K(), value: A(AST_Accessor), end: z()}));
					continue
				}
				if (ab == "set") {
					S.push(new AST_ObjectSetter({start: ae, key: K(), value: A(AST_Accessor), end: z()}));
					continue
				}
			}
			d(":");
			S.push(new AST_ObjectKeyVal({start: ae, key: ab, value: r(false), end: z()}))
		}
		i();
		return new AST_Object({properties: S})
	});

	function q() {
		var S = k.token;
		i();
		switch (S.type) {
			case"num":
			case"string":
			case"name":
			case"operator":
			case"keyword":
			case"atom":
				return S.value;
			default:
				J()
		}
	}

	function O() {
		var S = k.token;
		i();
		switch (S.type) {
			case"name":
			case"operator":
			case"keyword":
			case"atom":
				return S.value;
			default:
				J()
		}
	}

	function Q(ab) {
		var S = k.token.value;
		return new (S == "this" ? AST_This : ab)({name: String(S), start: k.token, end: k.token})
	}

	function M(ab, ac) {
		if (!v("name")) {
			if (!ac) {
				h("Name expected")
			}
			return null
		}
		var S = Q(ab);
		i();
		return S
	}

	var E = function (ab, S) {
		var ad = ab.start;
		if (v("punc", ".")) {
			i();
			return E(new AST_Dot({start: ad, expression: ab, property: O(), end: z()}), S)
		}
		if (v("punc", "[")) {
			i();
			var ac = r(true);
			d("]");
			return E(new AST_Sub({start: ad, expression: ab, property: ac, end: z()}), S)
		}
		if (S && v("punc", "(")) {
			i();
			return E(new AST_Call({start: ad, expression: ab, args: Y(")"), end: z()}), true)
		}
		return ab
	};
	var G = function (S) {
		var ad = k.token;
		if (v("operator") && UNARY_PREFIX(ad.value)) {
			i();
			y();
			var ab = f(AST_UnaryPrefix, ad.value, G(S));
			ab.start = ad;
			ab.end = z();
			return ab
		}
		var ac = x(S);
		while (v("operator") && UNARY_POSTFIX(k.token.value) && !k.token.nlb) {
			ac = f(AST_UnaryPostfix, k.token.value, ac);
			ac.start = ad;
			ac.end = k.token;
			i()
		}
		return ac
	};

	function f(S, ac, ab) {
		if ((ac == "++" || ac == "--") && !F(ab)) {
			h("Invalid use of " + ac + " operator")
		}
		return new S({operator: ac, expression: ab})
	}

	var P = function (ae, ad, S) {
		var af = v("operator") ? k.token.value : null;
		if (af == "in" && S) {
			af = null
		}
		var ab = af != null ? PRECEDENCE[af] : null;
		if (ab != null && ab > ad) {
			i();
			var ac = P(G(true), ab, S);
			return P(new AST_Binary({start: ae.start, left: ae, operator: af, right: ac, end: ac.end}), ad, S)
		}
		return ae
	};

	function n(S) {
		return P(G(true), 0, S)
	}

	var Z = function (S) {
		var ad = k.token;
		var ab = n(S);
		if (v("operator", "?")) {
			i();
			var ac = r(false);
			d(":");
			return new AST_Conditional({start: ad, condition: ab, consequent: ac, alternative: r(false, S), end: z()})
		}
		return ab
	};

	function F(S) {
		if (!s.strict) {
			return true
		}
		if (S instanceof AST_This) {
			return false
		}
		return (S instanceof AST_PropAccess || S instanceof AST_Symbol)
	}

	var X = function (S) {
		var ad = k.token;
		var ab = Z(S), ac = k.token.value;
		if (v("operator") && ASSIGNMENT(ac)) {
			if (F(ab)) {
				i();
				return new AST_Assign({start: ad, left: ab, operator: ac, right: X(S), end: z()})
			}
			h("Invalid assignment")
		}
		return ab
	};
	var r = function (ab, S) {
		var ad = k.token;
		var ac = X(S);
		if (ab && v("punc", ",")) {
			i();
			return new AST_Seq({start: ad, car: ac, cdr: r(true, S), end: m()})
		}
		return ac
	};

	function j(S) {
		++k.in_loop;
		var ab = S();
		--k.in_loop;
		return ab
	}

	if (s.expression) {
		return r(true)
	}
	return (function () {
		var ad = k.token;
		var S = [];
		while (!v("eof")) {
			S.push(t())
		}
		var ab = z();
		var ac = s.toplevel;
		if (ac) {
			ac.body = ac.body.concat(S);
			ac.end = ab
		} else {
			ac = new AST_Toplevel({start: ad, body: S, end: ab})
		}
		return ac
	})()
};
"use strict";
function SymbolDef(b, a, c) {
	this.name = c.name;
	this.orig = [c];
	this.scope = b;
	this.references = [];
	this.global = false;
	this.mangled_name = null;
	this.undeclared = false;
	this.constant = false;
	this.index = a
}
SymbolDef.prototype = {
	unmangleable: function (options) {
		return (this.global && !(options && options.toplevel)) || this.undeclared || (!(options && options.eval) && (this.scope.uses_eval || this.scope.uses_with))
	}, mangle: function (a) {
		if (!this.mangled_name && !this.unmangleable(a)) {
			var b = this.scope;
			if (!a.screw_ie8 && this.orig[0] instanceof AST_SymbolLambda) {
				b = b.parent_scope
			}
			this.mangled_name = b.next_mangled(a, this)
		}
	}
};
AST_Toplevel.DEFMETHOD("figure_out_scope", function (d) {
	d = defaults(d, {screw_ie8: false});
	var c = this;
	var e = c.parent_scope = null;
	var a = null;
	var h = 0;
	var b = new TreeWalker(function (m, l) {
		if (d.screw_ie8 && m instanceof AST_Catch) {
			var j = e;
			e = new AST_Scope(m);
			e.init_scope_vars(h);
			e.parent_scope = j;
			l();
			e = j;
			return true
		}
		if (m instanceof AST_Scope) {
			m.init_scope_vars(h);
			var j = m.parent_scope = e;
			var i = a;
			a = e = m;
			++h;
			l();
			--h;
			e = j;
			a = i;
			return true
		}
		if (m instanceof AST_Directive) {
			m.scope = e;
			push_uniq(e.directives, m.value);
			return true
		}
		if (m instanceof AST_With) {
			for (var k = e; k; k = k.parent_scope) {
				k.uses_with = true
			}
			return
		}
		if (m instanceof AST_Symbol) {
			m.scope = e
		}
		if (m instanceof AST_SymbolLambda) {
			a.def_function(m)
		} else {
			if (m instanceof AST_SymbolDefun) {
				(m.scope = a.parent_scope).def_function(m)
			} else {
				if (m instanceof AST_SymbolVar || m instanceof AST_SymbolConst) {
					var n = a.def_variable(m);
					n.constant = m instanceof AST_SymbolConst;
					n.init = b.parent().value
				} else {
					if (m instanceof AST_SymbolCatch) {
						(d.screw_ie8 ? e : a).def_variable(m)
					}
				}
			}
		}
	});
	c.walk(b);
	var g = null;
	var f = c.globals = new Dictionary();
	var b = new TreeWalker(function (n, l) {
		if (n instanceof AST_Lambda) {
			var o = g;
			g = n;
			l();
			g = o;
			return true
		}
		if (n instanceof AST_SymbolRef) {
			var j = n.name;
			var i = n.scope.find_variable(j);
			if (!i) {
				var m;
				if (f.has(j)) {
					m = f.get(j)
				} else {
					m = new SymbolDef(c, f.size(), n);
					m.undeclared = true;
					m.global = true;
					f.set(j, m)
				}
				n.thedef = m;
				if (j == "eval" && b.parent() instanceof AST_Call) {
					for (var k = n.scope; k && !k.uses_eval; k = k.parent_scope) {
						k.uses_eval = true
					}
				}
				if (g && j == "arguments") {
					g.uses_arguments = true
				}
			} else {
				n.thedef = i
			}
			n.reference();
			return true
		}
	});
	c.walk(b)
});
AST_Scope.DEFMETHOD("init_scope_vars", function (a) {
	this.directives = [];
	this.variables = new Dictionary();
	this.functions = new Dictionary();
	this.uses_with = false;
	this.uses_eval = false;
	this.parent_scope = null;
	this.enclosed = [];
	this.cname = -1;
	this.nesting = a
});
AST_Scope.DEFMETHOD("strict", function () {
	return this.has_directive("use strict")
});
AST_Lambda.DEFMETHOD("init_scope_vars", function () {
	AST_Scope.prototype.init_scope_vars.apply(this, arguments);
	this.uses_arguments = false
});
AST_SymbolRef.DEFMETHOD("reference", function () {
	var b = this.definition();
	b.references.push(this);
	var a = this.scope;
	while (a) {
		push_uniq(a.enclosed, b);
		if (a === b.scope) {
			break
		}
		a = a.parent_scope
	}
	this.frame = this.scope.nesting - b.scope.nesting
});
AST_Scope.DEFMETHOD("find_variable", function (a) {
	if (a instanceof AST_Symbol) {
		a = a.name
	}
	return this.variables.get(a) || (this.parent_scope && this.parent_scope.find_variable(a))
});
AST_Scope.DEFMETHOD("has_directive", function (a) {
	return this.parent_scope && this.parent_scope.has_directive(a) || (this.directives.indexOf(a) >= 0 ? this : null)
});
AST_Scope.DEFMETHOD("def_function", function (a) {
	this.functions.set(a.name, this.def_variable(a))
});
AST_Scope.DEFMETHOD("def_variable", function (b) {
	var a;
	if (!this.variables.has(b.name)) {
		a = new SymbolDef(this, this.variables.size(), b);
		this.variables.set(b.name, a);
		a.global = !this.parent_scope
	} else {
		a = this.variables.get(b.name);
		a.orig.push(b)
	}
	return b.thedef = a
});
AST_Scope.DEFMETHOD("next_mangled", function (d) {
	var f = this.enclosed;
	out:while (true) {
		var a = base54(++this.cname);
		if (!is_identifier(a)) {
			continue
		}
		if (d.except.indexOf(a) >= 0) {
			continue
		}
		for (var e = f.length; --e >= 0;) {
			var b = f[e];
			var c = b.mangled_name || (b.unmangleable(d) && b.name);
			if (a == c) {
				continue out
			}
		}
		return a
	}
});
AST_Function.DEFMETHOD("next_mangled", function (b, d) {
	var c = d.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();
	while (true) {
		var a = AST_Lambda.prototype.next_mangled.call(this, b, d);
		if (!(c && c.mangled_name == a)) {
			return a
		}
	}
});
AST_Scope.DEFMETHOD("references", function (a) {
	if (a instanceof AST_Symbol) {
		a = a.definition()
	}
	return this.enclosed.indexOf(a) < 0 ? null : a
});
AST_Symbol.DEFMETHOD("unmangleable", function (a) {
	return this.definition().unmangleable(a)
});
AST_SymbolAccessor.DEFMETHOD("unmangleable", function () {
	return true
});
AST_Label.DEFMETHOD("unmangleable", function () {
	return false
});
AST_Symbol.DEFMETHOD("unreferenced", function () {
	return this.definition().references.length == 0 && !(this.scope.uses_eval || this.scope.uses_with)
});
AST_Symbol.DEFMETHOD("undeclared", function () {
	return this.definition().undeclared
});
AST_LabelRef.DEFMETHOD("undeclared", function () {
	return false
});
AST_Label.DEFMETHOD("undeclared", function () {
	return false
});
AST_Symbol.DEFMETHOD("definition", function () {
	return this.thedef
});
AST_Symbol.DEFMETHOD("global", function () {
	return this.definition().global
});
AST_Toplevel.DEFMETHOD("_default_mangler_options", function (options) {
	return defaults(options, {except: [], eval: false, sort: false, toplevel: false, screw_ie8: false})
});
AST_Toplevel.DEFMETHOD("mangle_names", function (c) {
	c = this._default_mangler_options(c);
	var b = -1;
	var d = [];
	var a = new TreeWalker(function (i, h) {
		if (i instanceof AST_LabeledStatement) {
			var g = b;
			h();
			b = g;
			return true
		}
		if (i instanceof AST_Scope) {
			var j = a.parent(), e = [];
			i.variables.each(function (k) {
				if (c.except.indexOf(k.name) < 0) {
					e.push(k)
				}
			});
			if (c.sort) {
				e.sort(function (l, k) {
					return k.references.length - l.references.length
				})
			}
			d.push.apply(d, e);
			return
		}
		if (i instanceof AST_Label) {
			var f;
			do {
				f = base54(++b)
			} while (!is_identifier(f));
			i.mangled_name = f;
			return true
		}
		if (c.screw_ie8 && i instanceof AST_SymbolCatch) {
			d.push(i.definition());
			return
		}
	});
	this.walk(a);
	d.forEach(function (e) {
		e.mangle(c)
	})
});
AST_Toplevel.DEFMETHOD("compute_char_frequency", function (b) {
	b = this._default_mangler_options(b);
	var a = new TreeWalker(function (c) {
		if (c instanceof AST_Constant) {
			base54.consider(c.print_to_string())
		} else {
			if (c instanceof AST_Return) {
				base54.consider("return")
			} else {
				if (c instanceof AST_Throw) {
					base54.consider("throw")
				} else {
					if (c instanceof AST_Continue) {
						base54.consider("continue")
					} else {
						if (c instanceof AST_Break) {
							base54.consider("break")
						} else {
							if (c instanceof AST_Debugger) {
								base54.consider("debugger")
							} else {
								if (c instanceof AST_Directive) {
									base54.consider(c.value)
								} else {
									if (c instanceof AST_While) {
										base54.consider("while")
									} else {
										if (c instanceof AST_Do) {
											base54.consider("do while")
										} else {
											if (c instanceof AST_If) {
												base54.consider("if");
												if (c.alternative) {
													base54.consider("else")
												}
											} else {
												if (c instanceof AST_Var) {
													base54.consider("var")
												} else {
													if (c instanceof AST_Const) {
														base54.consider("const")
													} else {
														if (c instanceof AST_Lambda) {
															base54.consider("function")
														} else {
															if (c instanceof AST_For) {
																base54.consider("for")
															} else {
																if (c instanceof AST_ForIn) {
																	base54.consider("for in")
																} else {
																	if (c instanceof AST_Switch) {
																		base54.consider("switch")
																	} else {
																		if (c instanceof AST_Case) {
																			base54.consider("case")
																		} else {
																			if (c instanceof AST_Default) {
																				base54.consider("default")
																			} else {
																				if (c instanceof AST_With) {
																					base54.consider("with")
																				} else {
																					if (c instanceof AST_ObjectSetter) {
																						base54.consider("set" + c.key)
																					} else {
																						if (c instanceof AST_ObjectGetter) {
																							base54.consider("get" + c.key)
																						} else {
																							if (c instanceof AST_ObjectKeyVal) {
																								base54.consider(c.key)
																							} else {
																								if (c instanceof AST_New) {
																									base54.consider("new")
																								} else {
																									if (c instanceof AST_This) {
																										base54.consider("this")
																									} else {
																										if (c instanceof AST_Try) {
																											base54.consider("try")
																										} else {
																											if (c instanceof AST_Catch) {
																												base54.consider("catch")
																											} else {
																												if (c instanceof AST_Finally) {
																													base54.consider("finally")
																												} else {
																													if (c instanceof AST_Symbol && c.unmangleable(b)) {
																														base54.consider(c.name)
																													} else {
																														if (c instanceof AST_Unary || c instanceof AST_Binary) {
																															base54.consider(c.operator)
																														} else {
																															if (c instanceof AST_Dot) {
																																base54.consider(c.property)
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	});
	this.walk(a);
	base54.sort()
});
var base54 = (function () {
	var a = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";
	var c, d;

	function b() {
		d = Object.create(null);
		c = a.split("").map(function (f) {
			return f.charCodeAt(0)
		});
		c.forEach(function (f) {
			d[f] = 0
		})
	}

	e.consider = function (h) {
		for (var f = h.length; --f >= 0;) {
			var g = h.charCodeAt(f);
			if (g in d) {
				++d[g]
			}
		}
	};
	e.sort = function () {
		c = mergeSort(c, function (g, f) {
			if (is_digit(g) && !is_digit(f)) {
				return 1
			}
			if (is_digit(f) && !is_digit(g)) {
				return -1
			}
			return d[f] - d[g]
		})
	};
	e.reset = b;
	b();
	e.get = function () {
		return c
	};
	e.freq = function () {
		return d
	};
	function e(g) {
		var f = "", h = 54;
		do {
			f += String.fromCharCode(c[g % h]);
			g = Math.floor(g / h);
			h = 64
		} while (g > 0);
		return f
	}

	return e
})();
AST_Toplevel.DEFMETHOD("scope_warnings", function (options) {
	options = defaults(options, {
		undeclared: false,
		unreferenced: true,
		assign_to_global: true,
		func_arguments: true,
		nested_defuns: true,
		eval: true
	});
	var tw = new TreeWalker(function (node) {
		if (options.undeclared && node instanceof AST_SymbolRef && node.undeclared()) {
			AST_Node.warn("Undeclared symbol: {name} [{file}:{line},{col}]", {
				name: node.name,
				file: node.start.file,
				line: node.start.line,
				col: node.start.col
			})
		}
		if (options.assign_to_global) {
			var sym = null;
			if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef) {
				sym = node.left
			} else {
				if (node instanceof AST_ForIn && node.init instanceof AST_SymbolRef) {
					sym = node.init
				}
			}
			if (sym && (sym.undeclared() || (sym.global() && sym.scope !== sym.definition().scope))) {
				AST_Node.warn("{msg}: {name} [{file}:{line},{col}]", {
					msg: sym.undeclared() ? "Accidental global?" : "Assignment to global",
					name: sym.name,
					file: sym.start.file,
					line: sym.start.line,
					col: sym.start.col
				})
			}
		}
		if (options.eval && node instanceof AST_SymbolRef && node.undeclared() && node.name == "eval") {
			AST_Node.warn("Eval is used [{file}:{line},{col}]", node.start)
		}
		if (options.unreferenced && (node instanceof AST_SymbolDeclaration || node instanceof AST_Label) && node.unreferenced()) {
			AST_Node.warn("{type} {name} is declared but not referenced [{file}:{line},{col}]", {
				type: node instanceof AST_Label ? "Label" : "Symbol",
				name: node.name,
				file: node.start.file,
				line: node.start.line,
				col: node.start.col
			})
		}
		if (options.func_arguments && node instanceof AST_Lambda && node.uses_arguments) {
			AST_Node.warn("arguments used in function {name} [{file}:{line},{col}]", {
				name: node.name ? node.name.name : "anonymous",
				file: node.start.file,
				line: node.start.line,
				col: node.start.col
			})
		}
		if (options.nested_defuns && node instanceof AST_Defun && !(tw.parent() instanceof AST_Scope)) {
			AST_Node.warn('Function {name} declared in nested statement "{type}" [{file}:{line},{col}]', {
				name: node.name.name,
				type: tw.parent().TYPE,
				file: node.start.file,
				line: node.start.line,
				col: node.start.col
			})
		}
	});
	this.walk(tw)
});
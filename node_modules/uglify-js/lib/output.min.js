"use strict";
function OutputStream(e) {
	e = defaults(e, {
		indent_start: 0,
		indent_level: 4,
		quote_keys: false,
		space_colon: true,
		ascii_only: false,
		unescape_regexps: false,
		inline_script: false,
		width: 80,
		max_line_len: 32000,
		beautify: false,
		source_map: null,
		bracketize: false,
		semicolons: true,
		comments: false,
		preserve_line: false,
		screw_ie8: false,
		preamble: null
	}, true);
	var a = 0;
	var r = 0;
	var o = 1;
	var s = 0;
	var E = "";

	function p(I, H) {
		return I.replace(/[\u0080-\uffff]/g, function (J) {
			var K = J.charCodeAt(0).toString(16);
			if (K.length <= 2 && !H) {
				while (K.length < 2) {
					K = "0" + K
				}
				return "\\x" + K
			} else {
				while (K.length < 4) {
					K = "0" + K
				}
				return "\\u" + K
			}
		})
	}

	function j(J) {
		var I = 0, H = 0;
		J = J.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function (K) {
			switch (K) {
				case"\\":
					return "\\\\";
				case"\b":
					return "\\b";
				case"\f":
					return "\\f";
				case"\n":
					return "\\n";
				case"\r":
					return "\\r";
				case"\u2028":
					return "\\u2028";
				case"\u2029":
					return "\\u2029";
				case'"':
					++I;
					return '"';
				case"'":
					++H;
					return "'";
				case"\0":
					return "\\x00"
			}
			return K
		});
		if (e.ascii_only) {
			J = p(J)
		}
		if (I > H) {
			return "'" + J.replace(/\x27/g, "\\'") + "'"
		} else {
			return '"' + J.replace(/\x22/g, '\\"') + '"'
		}
	}

	function t(I) {
		var H = j(I);
		if (e.inline_script) {
			H = H.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1")
		}
		return H
	}

	function m(H) {
		H = H.toString();
		if (e.ascii_only) {
			H = p(H, true)
		}
		return H
	}

	function B(H) {
		return repeat_string(" ", e.indent_start + a - H * e.indent_level)
	}

	var h = false;
	var x = false;
	var k = null;

	function u() {
		return k.charAt(k.length - 1)
	}

	function l() {
		if (e.max_line_len && r > e.max_line_len) {
			d("\n")
		}
	}

	var g = makePredicate("( [ + * / - , .");

	function d(L) {
		L = String(L);
		var J = L.charAt(0);
		if (x) {
			if ((!J || ";}".indexOf(J) < 0) && !/[;]$/.test(k)) {
				if (e.semicolons || g(J)) {
					E += ";";
					r++;
					s++
				} else {
					E += "\n";
					s++;
					o++;
					r = 0
				}
				if (!e.beautify) {
					h = false
				}
			}
			x = false;
			l()
		}
		if (!e.beautify && e.preserve_line && f[f.length - 1]) {
			var I = f[f.length - 1].start.line;
			while (o < I) {
				E += "\n";
				s++;
				o++;
				r = 0;
				h = false
			}
		}
		if (h) {
			var K = u();
			if ((is_identifier_char(K) && (is_identifier_char(J) || J == "\\")) || (/^[\+\-\/]$/.test(J) && J == K)) {
				E += " ";
				r++;
				s++
			}
			h = false
		}
		var H = L.split(/\r?\n/), M = H.length - 1;
		o += M;
		if (M == 0) {
			r += H[M].length
		} else {
			r = H[M].length
		}
		s += L.length;
		k = L;
		E += L
	}

	var A = e.beautify ? function () {
		d(" ")
	} : function () {
		h = true
	};
	var n = e.beautify ? function (H) {
		if (e.beautify) {
			d(B(H ? 0.5 : 0))
		}
	} : noop;
	var w = e.beautify ? function (J, H) {
		if (J === true) {
			J = F()
		}
		var K = a;
		a = J;
		var I = H();
		a = K;
		return I
	} : function (I, H) {
		return H()
	};
	var q = e.beautify ? function () {
		d("\n")
	} : noop;
	var i = e.beautify ? function () {
		d(";")
	} : function () {
		x = true
	};

	function c() {
		x = false;
		d(";")
	}

	function F() {
		return a + e.indent_level
	}

	function z(H) {
		var I;
		d("{");
		q();
		w(F(), function () {
			I = H()
		});
		n();
		d("}");
		return I
	}

	function v(H) {
		d("(");
		var I = H();
		d(")");
		return I
	}

	function D(H) {
		d("[");
		var I = H();
		d("]");
		return I
	}

	function G() {
		d(",");
		A()
	}

	function y() {
		d(":");
		if (e.space_colon) {
			A()
		}
	}

	var b = e.source_map ? function (J, H) {
		try {
			if (J) {
				e.source_map.add(J.file || "?", o, r, J.line, J.col, (!H && J.type == "name") ? J.value : H)
			}
		} catch (I) {
			AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} â†’ {cline},{ccol} [{name}]", {
				file: J.file,
				line: J.line,
				col: J.col,
				cline: o,
				ccol: r,
				name: H || ""
			})
		}
	} : noop;

	function C() {
		return E
	}

	if (e.preamble) {
		d(e.preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"))
	}
	var f = [];
	return {
		get: C,
		toString: C,
		indent: n,
		indentation: function () {
			return a
		},
		current_width: function () {
			return r - a
		},
		should_break: function () {
			return e.width && this.current_width() >= e.width
		},
		newline: q,
		print: d,
		space: A,
		comma: G,
		colon: y,
		last: function () {
			return k
		},
		semicolon: i,
		force_semicolon: c,
		to_ascii: p,
		print_name: function (H) {
			d(m(H))
		},
		print_string: function (H) {
			d(t(H))
		},
		next_indent: F,
		with_indent: w,
		with_block: z,
		with_parens: v,
		with_square: D,
		add_mapping: b,
		option: function (H) {
			return e[H]
		},
		line: function () {
			return o
		},
		col: function () {
			return r
		},
		pos: function () {
			return s
		},
		push_node: function (H) {
			f.push(H)
		},
		pop_node: function () {
			return f.pop()
		},
		stack: function () {
			return f
		},
		parent: function (H) {
			return f[f.length - 2 - (H || 0)]
		}
	}
}
(function () {
	function h(q, r) {
		q.DEFMETHOD("_codegen", r)
	}

	AST_Node.DEFMETHOD("print", function (u, r) {
		var q = this, s = q._codegen;

		function t() {
			q.add_comments(u);
			q.add_source_map(u);
			s(q, u)
		}

		u.push_node(q);
		if (r || q.needs_parens(u)) {
			u.with_parens(t)
		} else {
			t()
		}
		u.pop_node()
	});
	AST_Node.DEFMETHOD("print_to_string", function (q) {
		var r = OutputStream(q);
		this.print(r);
		return r.get()
	});
	AST_Node.DEFMETHOD("add_comments", function (r) {
		var u = r.option("comments"), q = this;
		if (u) {
			var t = q.start;
			if (t && !t._comments_dumped) {
				t._comments_dumped = true;
				var s = t.comments_before || [];
				if (q instanceof AST_Exit && q.value) {
					q.value.walk(new TreeWalker(function (v) {
						if (v.start && v.start.comments_before) {
							s = s.concat(v.start.comments_before);
							v.start.comments_before = []
						}
						if (v instanceof AST_Function || v instanceof AST_Array || v instanceof AST_Object) {
							return true
						}
					}))
				}
				if (u.test) {
					s = s.filter(function (v) {
						return u.test(v.value)
					})
				} else {
					if (typeof u == "function") {
						s = s.filter(function (v) {
							return u(q, v)
						})
					}
				}
				s.forEach(function (v) {
					if (/comment[134]/.test(v.type)) {
						r.print("//" + v.value + "\n");
						r.indent()
					} else {
						if (v.type == "comment2") {
							r.print("/*" + v.value + "*/");
							if (t.nlb) {
								r.print("\n");
								r.indent()
							} else {
								r.space()
							}
						}
					}
				})
			}
		}
	});
	function m(q, r) {
		q.DEFMETHOD("needs_parens", r)
	}

	m(AST_Node, function () {
		return false
	});
	m(AST_Function, function (q) {
		return f(q)
	});
	m(AST_Object, function (q) {
		return f(q)
	});
	m(AST_Unary, function (q) {
		var r = q.parent();
		return r instanceof AST_PropAccess && r.expression === this
	});
	m(AST_Seq, function (q) {
		var r = q.parent();
		return r instanceof AST_Call || r instanceof AST_Unary || r instanceof AST_Binary || r instanceof AST_VarDef || r instanceof AST_PropAccess || r instanceof AST_Array || r instanceof AST_ObjectProperty || r instanceof AST_Conditional
	});
	m(AST_Binary, function (s) {
		var v = s.parent();
		if (v instanceof AST_Call && v.expression === this) {
			return true
		}
		if (v instanceof AST_Unary) {
			return true
		}
		if (v instanceof AST_PropAccess && v.expression === this) {
			return true
		}
		if (v instanceof AST_Binary) {
			var r = v.operator, q = PRECEDENCE[r];
			var u = this.operator, t = PRECEDENCE[u];
			if (q > t || (q == t && this === v.right)) {
				return true
			}
		}
	});
	m(AST_PropAccess, function (q) {
		var s = q.parent();
		if (s instanceof AST_New && s.expression === this) {
			try {
				this.walk(new TreeWalker(function (t) {
					if (t instanceof AST_Call) {
						throw s
					}
				}))
			} catch (r) {
				if (r !== s) {
					throw r
				}
				return true
			}
		}
	});
	m(AST_Call, function (q) {
		var r = q.parent(), s;
		if (r instanceof AST_New && r.expression === this) {
			return true
		}
		return this.expression instanceof AST_Function && r instanceof AST_PropAccess && r.expression === this && (s = q.parent(1)) instanceof AST_Assign && s.left === r
	});
	m(AST_New, function (q) {
		var r = q.parent();
		if (j(this, q) && (r instanceof AST_PropAccess || r instanceof AST_Call && r.expression === this)) {
			return true
		}
	});
	m(AST_Number, function (q) {
		var r = q.parent();
		if (this.getValue() < 0 && r instanceof AST_PropAccess && r.expression === this) {
			return true
		}
	});
	m(AST_NaN, function (q) {
		var r = q.parent();
		if (r instanceof AST_PropAccess && r.expression === this) {
			return true
		}
	});
	function c(q) {
		var r = q.parent();
		if (r instanceof AST_Unary) {
			return true
		}
		if (r instanceof AST_Binary && !(r instanceof AST_Assign)) {
			return true
		}
		if (r instanceof AST_Call && r.expression === this) {
			return true
		}
		if (r instanceof AST_Conditional && r.condition === this) {
			return true
		}
		if (r instanceof AST_PropAccess && r.expression === this) {
			return true
		}
	}

	m(AST_Assign, c);
	m(AST_Conditional, c);
	h(AST_Directive, function (r, q) {
		q.print_string(r.value);
		q.semicolon()
	});
	h(AST_Debugger, function (r, q) {
		q.print("debugger");
		q.semicolon()
	});
	function g(q, t, r) {
		var s = q.length - 1;
		q.forEach(function (v, u) {
			if (!(v instanceof AST_EmptyStatement)) {
				r.indent();
				v.print(r);
				if (!(u == s && t)) {
					r.newline();
					if (t) {
						r.newline()
					}
				}
			}
		})
	}

	AST_StatementWithBody.DEFMETHOD("_do_print_body", function (q) {
		l(this.body, q)
	});
	h(AST_Statement, function (r, q) {
		r.body.print(q);
		q.semicolon()
	});
	h(AST_Toplevel, function (r, q) {
		g(r.body, true, q);
		q.print("")
	});
	h(AST_LabeledStatement, function (r, q) {
		r.label.print(q);
		q.colon();
		r.body.print(q)
	});
	h(AST_SimpleStatement, function (r, q) {
		r.body.print(q);
		q.semicolon()
	});
	function k(q, r) {
		if (q.length > 0) {
			r.with_block(function () {
				g(q, false, r)
			})
		} else {
			r.print("{}")
		}
	}

	h(AST_BlockStatement, function (r, q) {
		k(r.body, q)
	});
	h(AST_EmptyStatement, function (r, q) {
		q.semicolon()
	});
	h(AST_Do, function (r, q) {
		q.print("do");
		q.space();
		r._do_print_body(q);
		q.space();
		q.print("while");
		q.space();
		q.with_parens(function () {
			r.condition.print(q)
		});
		q.semicolon()
	});
	h(AST_While, function (r, q) {
		q.print("while");
		q.space();
		q.with_parens(function () {
			r.condition.print(q)
		});
		q.space();
		r._do_print_body(q)
	});
	h(AST_For, function (r, q) {
		q.print("for");
		q.space();
		q.with_parens(function () {
			if (r.init && !(r.init instanceof AST_EmptyStatement)) {
				if (r.init instanceof AST_Definitions) {
					r.init.print(q)
				} else {
					b(r.init, q, true)
				}
				q.print(";");
				q.space()
			} else {
				q.print(";")
			}
			if (r.condition) {
				r.condition.print(q);
				q.print(";");
				q.space()
			} else {
				q.print(";")
			}
			if (r.step) {
				r.step.print(q)
			}
		});
		q.space();
		r._do_print_body(q)
	});
	h(AST_ForIn, function (r, q) {
		q.print("for");
		q.space();
		q.with_parens(function () {
			r.init.print(q);
			q.space();
			q.print("in");
			q.space();
			r.object.print(q)
		});
		q.space();
		r._do_print_body(q)
	});
	h(AST_With, function (r, q) {
		q.print("with");
		q.space();
		q.with_parens(function () {
			r.expression.print(q)
		});
		q.space();
		r._do_print_body(q)
	});
	AST_Lambda.DEFMETHOD("_do_print", function (r, s) {
		var q = this;
		if (!s) {
			r.print("function")
		}
		if (q.name) {
			r.space();
			q.name.print(r)
		}
		r.with_parens(function () {
			q.argnames.forEach(function (t, u) {
				if (u) {
					r.comma()
				}
				t.print(r)
			})
		});
		r.space();
		k(q.body, r)
	});
	h(AST_Lambda, function (r, q) {
		r._do_print(q)
	});
	AST_Exit.DEFMETHOD("_do_print", function (q, r) {
		q.print(r);
		if (this.value) {
			q.space();
			this.value.print(q)
		}
		q.semicolon()
	});
	h(AST_Return, function (r, q) {
		r._do_print(q, "return")
	});
	h(AST_Throw, function (r, q) {
		r._do_print(q, "throw")
	});
	AST_LoopControl.DEFMETHOD("_do_print", function (q, r) {
		q.print(r);
		if (this.label) {
			q.space();
			this.label.print(q)
		}
		q.semicolon()
	});
	h(AST_Break, function (r, q) {
		r._do_print(q, "break")
	});
	h(AST_Continue, function (r, q) {
		r._do_print(q, "continue")
	});
	function p(s, r) {
		if (r.option("bracketize")) {
			n(s.body, r);
			return
		}
		if (!s.body) {
			return r.force_semicolon()
		}
		if (s.body instanceof AST_Do && !r.option("screw_ie8")) {
			n(s.body, r);
			return
		}
		var q = s.body;
		while (true) {
			if (q instanceof AST_If) {
				if (!q.alternative) {
					n(s.body, r);
					return
				}
				q = q.alternative
			} else {
				if (q instanceof AST_StatementWithBody) {
					q = q.body
				} else {
					break
				}
			}
		}
		l(s.body, r)
	}

	h(AST_If, function (r, q) {
		q.print("if");
		q.space();
		q.with_parens(function () {
			r.condition.print(q)
		});
		q.space();
		if (r.alternative) {
			p(r, q);
			q.space();
			q.print("else");
			q.space();
			l(r.alternative, q)
		} else {
			r._do_print_body(q)
		}
	});
	h(AST_Switch, function (r, q) {
		q.print("switch");
		q.space();
		q.with_parens(function () {
			r.expression.print(q)
		});
		q.space();
		if (r.body.length > 0) {
			q.with_block(function () {
				r.body.forEach(function (t, s) {
					if (s) {
						q.newline()
					}
					q.indent(true);
					t.print(q)
				})
			})
		} else {
			q.print("{}")
		}
	});
	AST_SwitchBranch.DEFMETHOD("_do_print_body", function (q) {
		if (this.body.length > 0) {
			q.newline();
			this.body.forEach(function (r) {
				q.indent();
				r.print(q);
				q.newline()
			})
		}
	});
	h(AST_Default, function (r, q) {
		q.print("default:");
		r._do_print_body(q)
	});
	h(AST_Case, function (r, q) {
		q.print("case");
		q.space();
		r.expression.print(q);
		q.print(":");
		r._do_print_body(q)
	});
	h(AST_Try, function (r, q) {
		q.print("try");
		q.space();
		k(r.body, q);
		if (r.bcatch) {
			q.space();
			r.bcatch.print(q)
		}
		if (r.bfinally) {
			q.space();
			r.bfinally.print(q)
		}
	});
	h(AST_Catch, function (r, q) {
		q.print("catch");
		q.space();
		q.with_parens(function () {
			r.argname.print(q)
		});
		q.space();
		k(r.body, q)
	});
	h(AST_Finally, function (r, q) {
		q.print("finally");
		q.space();
		k(r.body, q)
	});
	AST_Definitions.DEFMETHOD("_do_print", function (q, t) {
		q.print(t);
		q.space();
		this.definitions.forEach(function (w, v) {
			if (v) {
				q.comma()
			}
			w.print(q)
		});
		var u = q.parent();
		var s = u instanceof AST_For || u instanceof AST_ForIn;
		var r = s && u.init === this;
		if (!r) {
			q.semicolon()
		}
	});
	h(AST_Var, function (r, q) {
		r._do_print(q, "var")
	});
	h(AST_Const, function (r, q) {
		r._do_print(q, "const")
	});
	function b(s, q, t) {
		if (!t) {
			s.print(q)
		} else {
			try {
				s.walk(new TreeWalker(function (u) {
					if (u instanceof AST_Binary && u.operator == "in") {
						throw q
					}
				}));
				s.print(q)
			} catch (r) {
				if (r !== q) {
					throw r
				}
				s.print(q, true)
			}
		}
	}

	h(AST_VarDef, function (r, q) {
		r.name.print(q);
		if (r.value) {
			q.space();
			q.print("=");
			q.space();
			var t = q.parent(1);
			var s = t instanceof AST_For || t instanceof AST_ForIn;
			b(r.value, q, s)
		}
	});
	h(AST_Call, function (r, q) {
		r.expression.print(q);
		if (r instanceof AST_New && j(r, q)) {
			return
		}
		q.with_parens(function () {
			r.args.forEach(function (t, s) {
				if (s) {
					q.comma()
				}
				t.print(q)
			})
		})
	});
	h(AST_New, function (r, q) {
		q.print("new");
		q.space();
		AST_Call.prototype._codegen(r, q)
	});
	AST_Seq.DEFMETHOD("_do_print", function (q) {
		this.car.print(q);
		if (this.cdr) {
			q.comma();
			if (q.should_break()) {
				q.newline();
				q.indent()
			}
			this.cdr.print(q)
		}
	});
	h(AST_Seq, function (r, q) {
		r._do_print(q)
	});
	h(AST_Dot, function (r, q) {
		var s = r.expression;
		s.print(q);
		if (s instanceof AST_Number && s.getValue() >= 0) {
			if (!/[xa-f.]/i.test(q.last())) {
				q.print(".")
			}
		}
		q.print(".");
		q.add_mapping(r.end);
		q.print_name(r.property)
	});
	h(AST_Sub, function (r, q) {
		r.expression.print(q);
		q.print("[");
		r.property.print(q);
		q.print("]")
	});
	h(AST_UnaryPrefix, function (r, q) {
		var s = r.operator;
		q.print(s);
		if (/^[a-z]/i.test(s) || (/[+-]$/.test(s) && r.expression instanceof AST_UnaryPrefix && /^[+-]/.test(r.expression.operator))) {
			q.space()
		}
		r.expression.print(q)
	});
	h(AST_UnaryPostfix, function (r, q) {
		r.expression.print(q);
		q.print(r.operator)
	});
	h(AST_Binary, function (r, q) {
		r.left.print(q);
		q.space();
		q.print(r.operator);
		if (r.operator == "<" && r.right instanceof AST_UnaryPrefix && r.right.operator == "!" && r.right.expression instanceof AST_UnaryPrefix && r.right.expression.operator == "--") {
			q.print(" ")
		} else {
			q.space()
		}
		r.right.print(q)
	});
	h(AST_Conditional, function (r, q) {
		r.condition.print(q);
		q.space();
		q.print("?");
		q.space();
		r.consequent.print(q);
		q.space();
		q.colon();
		r.alternative.print(q)
	});
	h(AST_Array, function (r, q) {
		q.with_square(function () {
			var t = r.elements, s = t.length;
			if (s > 0) {
				q.space()
			}
			t.forEach(function (v, u) {
				if (u) {
					q.comma()
				}
				v.print(q);
				if (u === s - 1 && v instanceof AST_Hole) {
					q.comma()
				}
			});
			if (s > 0) {
				q.space()
			}
		})
	});
	h(AST_Object, function (r, q) {
		if (r.properties.length > 0) {
			q.with_block(function () {
				r.properties.forEach(function (t, s) {
					if (s) {
						q.print(",");
						q.newline()
					}
					q.indent();
					t.print(q)
				});
				q.newline()
			})
		} else {
			q.print("{}")
		}
	});
	h(AST_ObjectKeyVal, function (r, q) {
		var s = r.key;
		if (q.option("quote_keys")) {
			q.print_string(s + "")
		} else {
			if ((typeof s == "number" || !q.option("beautify") && +s + "" == s) && parseFloat(s) >= 0) {
				q.print(o(s))
			} else {
				if (RESERVED_WORDS(s) ? q.option("screw_ie8") : is_identifier_string(s)) {
					q.print_name(s)
				} else {
					q.print_string(s)
				}
			}
		}
		q.colon();
		r.value.print(q)
	});
	h(AST_ObjectSetter, function (r, q) {
		q.print("set");
		q.space();
		r.key.print(q);
		r.value._do_print(q, true)
	});
	h(AST_ObjectGetter, function (r, q) {
		q.print("get");
		q.space();
		r.key.print(q);
		r.value._do_print(q, true)
	});
	h(AST_Symbol, function (r, q) {
		var s = r.definition();
		q.print_name(s ? s.mangled_name || s.name : r.name)
	});
	h(AST_Undefined, function (r, q) {
		q.print("void 0")
	});
	h(AST_Hole, noop);
	h(AST_Infinity, function (r, q) {
		q.print("1/0")
	});
	h(AST_NaN, function (r, q) {
		q.print("0/0")
	});
	h(AST_This, function (r, q) {
		q.print("this")
	});
	h(AST_Constant, function (r, q) {
		q.print(r.getValue())
	});
	h(AST_String, function (r, q) {
		q.print_string(r.getValue())
	});
	h(AST_Number, function (r, q) {
		q.print(o(r.getValue()))
	});
	function e(q) {
		return [92, 47, 46, 43, 42, 63, 40, 41, 91, 93, 123, 125, 36, 94, 58, 124, 33, 10, 13, 0, 65279, 8232, 8233].indexOf(q) < 0
	}

	h(AST_RegExp, function (r, q) {
		var t = r.getValue().toString();
		if (q.option("ascii_only")) {
			t = q.to_ascii(t)
		} else {
			if (q.option("unescape_regexps")) {
				t = t.split("\\\\").map(function (u) {
					return u.replace(/\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2}/g, function (v) {
						var w = parseInt(v.substr(2), 16);
						return e(w) ? String.fromCharCode(w) : v
					})
				}).join("\\\\")
			}
		}
		q.print(t);
		var s = q.parent();
		if (s instanceof AST_Binary && /^in/.test(s.operator) && s.left === r) {
			q.print(" ")
		}
	});
	function l(r, q) {
		if (q.option("bracketize")) {
			if (!r || r instanceof AST_EmptyStatement) {
				q.print("{}")
			} else {
				if (r instanceof AST_BlockStatement) {
					r.print(q)
				} else {
					q.with_block(function () {
						q.indent();
						r.print(q);
						q.newline()
					})
				}
			}
		} else {
			if (!r || r instanceof AST_EmptyStatement) {
				q.force_semicolon()
			} else {
				r.print(q)
			}
		}
	}

	function f(r) {
		var q = r.stack(), s = q.length, t = q[--s], u = q[--s];
		while (s > 0) {
			if (u instanceof AST_Statement && u.body === t) {
				return true
			}
			if ((u instanceof AST_Seq && u.car === t) || (u instanceof AST_Call && u.expression === t && !(u instanceof AST_New)) || (u instanceof AST_Dot && u.expression === t) || (u instanceof AST_Sub && u.expression === t) || (u instanceof AST_Conditional && u.condition === t) || (u instanceof AST_Binary && u.left === t) || (u instanceof AST_UnaryPostfix && u.expression === t)) {
				t = u;
				u = q[--s]
			} else {
				return false
			}
		}
	}

	function j(r, q) {
		return r.args.length == 0 && !q.option("beautify")
	}

	function i(r) {
		var t = r[0], q = t.length;
		for (var s = 1; s < r.length; ++s) {
			if (r[s].length < q) {
				t = r[s];
				q = t.length
			}
		}
		return t
	}

	function o(s) {
		var t = s.toString(10), r = [t.replace(/^0\./, ".").replace("e+", "e")], q;
		if (Math.floor(s) === s) {
			if (s >= 0) {
				r.push("0x" + s.toString(16).toLowerCase(), "0" + s.toString(8))
			} else {
				r.push("-0x" + (-s).toString(16).toLowerCase(), "-0" + (-s).toString(8))
			}
			if ((q = /^(.*?)(0+)$/.exec(s))) {
				r.push(q[1] + "e" + q[2].length)
			}
		} else {
			if ((q = /^0?\.(0+)(.*)$/.exec(s))) {
				r.push(q[2] + "e-" + (q[1].length + q[2].length), t.substr(t.indexOf(".")))
			}
		}
		return i(r)
	}

	function n(r, q) {
		if (r instanceof AST_BlockStatement) {
			r.print(q);
			return
		}
		q.with_block(function () {
			q.indent();
			r.print(q);
			q.newline()
		})
	}

	function a(q, r) {
		q.DEFMETHOD("add_source_map", function (s) {
			r(this, s)
		})
	}

	a(AST_Node, noop);
	function d(r, q) {
		q.add_mapping(r.start)
	}

	a(AST_Directive, d);
	a(AST_Debugger, d);
	a(AST_Symbol, d);
	a(AST_Jump, d);
	a(AST_StatementWithBody, d);
	a(AST_LabeledStatement, noop);
	a(AST_Lambda, d);
	a(AST_Switch, d);
	a(AST_SwitchBranch, d);
	a(AST_BlockStatement, d);
	a(AST_Toplevel, noop);
	a(AST_New, d);
	a(AST_Try, d);
	a(AST_Catch, d);
	a(AST_Finally, d);
	a(AST_Definitions, d);
	a(AST_Constant, d);
	a(AST_ObjectProperty, function (r, q) {
		q.add_mapping(r.start, r.key)
	})
})();